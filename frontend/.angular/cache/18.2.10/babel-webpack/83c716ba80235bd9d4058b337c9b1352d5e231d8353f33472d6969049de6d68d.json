{"ast":null,"code":"import _asyncToGenerator from \"C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { interactionCodeFlow } from './interactionCodeFlow.js';\nimport { FORMS } from '../ion/RemediationConstants.js';\nimport transformIdxResponse from '../ion/transformIdxResponse.js';\nfunction updateAppState(_x, _x2) {\n  return _updateAppState.apply(this, arguments);\n}\nfunction _updateAppState() {\n  _updateAppState = _asyncToGenerator(function* (appState, idxResponse) {\n    const settings = appState.settings;\n    const lastResponse = appState.get('idx');\n    const useInteractionCodeFlow = settings.get('oauth2Enabled');\n    if (useInteractionCodeFlow) {\n      if (idxResponse.interactionCode) {\n        // Although session.stateHandle isn't used by interation flow,\n        // it's better to clean up at the end of the flow.\n        sessionStorageHelper.removeStateHandle();\n        // This is the end of the IDX flow, now entering OAuth\n        const tokens = yield interactionCodeFlow(settings, idxResponse);\n        // At the successful end of IDX flow `clearAppStateCache` has been called, \n        //  but `setIonResponse` is not called, so `appState` is empty.\n        // In such case `FormController` is not able to render any form.\n        appState.unset('currentFormName', {\n          silent: true\n        });\n        return tokens;\n      }\n    } else {\n      // Do not save state handle for the first page loads.\n      // Because there shall be no difference between following behavior\n      // 1. bootstrap widget\n      //    -> save state handle to session storage\n      //    -> refresh page\n      //    -> introspect using sessionStorage.stateHandle\n      // 2. bootstrap widget\n      //    -> do not save state handle to session storage\n      //    -> refresh page\n      //    -> introspect using options.stateHandle\n      if (lastResponse) {\n        var _idxResponse$context;\n        sessionStorageHelper.setStateHandle(idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context = idxResponse.context) === null || _idxResponse$context === void 0 ? void 0 : _idxResponse$context.stateHandle);\n      }\n      // Login flows that mimic step up (moving forward in login pipeline) via internal api calls,\n      // need to clear stored stateHandles.\n      // This way the flow can maintain the latest state handle. For eg. Device probe calls\n      if (appState.get('currentFormName') === FORMS.CANCEL_TRANSACTION) {\n        sessionStorageHelper.removeStateHandle();\n      }\n    }\n\n    // transform response\n    const ionResponse = transformIdxResponse(settings, idxResponse, lastResponse);\n    yield appState.setIonResponse(ionResponse);\n  });\n  return _updateAppState.apply(this, arguments);\n}\nexport { updateAppState };","map":{"version":3,"names":["sessionStorageHelper","interactionCodeFlow","FORMS","transformIdxResponse","updateAppState","_x","_x2","_updateAppState","apply","arguments","_asyncToGenerator","appState","idxResponse","settings","lastResponse","get","useInteractionCodeFlow","interactionCode","removeStateHandle","tokens","unset","silent","_idxResponse$context","setStateHandle","context","stateHandle","CANCEL_TRANSACTION","ionResponse","setIonResponse"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/updateAppState.js"],"sourcesContent":["import sessionStorageHelper from './sessionStorageHelper.js';\nimport { interactionCodeFlow } from './interactionCodeFlow.js';\nimport { FORMS } from '../ion/RemediationConstants.js';\nimport transformIdxResponse from '../ion/transformIdxResponse.js';\n\nasync function updateAppState(appState, idxResponse) {\n  const settings = appState.settings;\n  const lastResponse = appState.get('idx');\n  const useInteractionCodeFlow = settings.get('oauth2Enabled');\n  if (useInteractionCodeFlow) {\n    if (idxResponse.interactionCode) {\n      // Although session.stateHandle isn't used by interation flow,\n      // it's better to clean up at the end of the flow.\n      sessionStorageHelper.removeStateHandle();\n      // This is the end of the IDX flow, now entering OAuth\n      const tokens = await interactionCodeFlow(settings, idxResponse);\n      // At the successful end of IDX flow `clearAppStateCache` has been called, \n      //  but `setIonResponse` is not called, so `appState` is empty.\n      // In such case `FormController` is not able to render any form.\n      appState.unset('currentFormName', {\n        silent: true\n      });\n      return tokens;\n    }\n  } else {\n    // Do not save state handle for the first page loads.\n    // Because there shall be no difference between following behavior\n    // 1. bootstrap widget\n    //    -> save state handle to session storage\n    //    -> refresh page\n    //    -> introspect using sessionStorage.stateHandle\n    // 2. bootstrap widget\n    //    -> do not save state handle to session storage\n    //    -> refresh page\n    //    -> introspect using options.stateHandle\n    if (lastResponse) {\n      var _idxResponse$context;\n      sessionStorageHelper.setStateHandle(idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context = idxResponse.context) === null || _idxResponse$context === void 0 ? void 0 : _idxResponse$context.stateHandle);\n    }\n    // Login flows that mimic step up (moving forward in login pipeline) via internal api calls,\n    // need to clear stored stateHandles.\n    // This way the flow can maintain the latest state handle. For eg. Device probe calls\n    if (appState.get('currentFormName') === FORMS.CANCEL_TRANSACTION) {\n      sessionStorageHelper.removeStateHandle();\n    }\n  }\n\n  // transform response\n  const ionResponse = transformIdxResponse(settings, idxResponse, lastResponse);\n  await appState.setIonResponse(ionResponse);\n}\n\nexport { updateAppState };\n"],"mappings":";AAAA,OAAOA,oBAAoB,MAAM,2BAA2B;AAC5D,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,KAAK,QAAQ,gCAAgC;AACtD,OAAOC,oBAAoB,MAAM,gCAAgC;AAAC,SAEnDC,cAAcA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,gBAAA;EAAAA,eAAA,GAAAG,iBAAA,CAA7B,WAA8BC,QAAQ,EAAEC,WAAW,EAAE;IACnD,MAAMC,QAAQ,GAAGF,QAAQ,CAACE,QAAQ;IAClC,MAAMC,YAAY,GAAGH,QAAQ,CAACI,GAAG,CAAC,KAAK,CAAC;IACxC,MAAMC,sBAAsB,GAAGH,QAAQ,CAACE,GAAG,CAAC,eAAe,CAAC;IAC5D,IAAIC,sBAAsB,EAAE;MAC1B,IAAIJ,WAAW,CAACK,eAAe,EAAE;QAC/B;QACA;QACAjB,oBAAoB,CAACkB,iBAAiB,CAAC,CAAC;QACxC;QACA,MAAMC,MAAM,SAASlB,mBAAmB,CAACY,QAAQ,EAAED,WAAW,CAAC;QAC/D;QACA;QACA;QACAD,QAAQ,CAACS,KAAK,CAAC,iBAAiB,EAAE;UAChCC,MAAM,EAAE;QACV,CAAC,CAAC;QACF,OAAOF,MAAM;MACf;IACF,CAAC,MAAM;MACL;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIL,YAAY,EAAE;QAChB,IAAIQ,oBAAoB;QACxBtB,oBAAoB,CAACuB,cAAc,CAACX,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACU,oBAAoB,GAAGV,WAAW,CAACY,OAAO,MAAM,IAAI,IAAIF,oBAAoB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAACG,WAAW,CAAC;MACrO;MACA;MACA;MACA;MACA,IAAId,QAAQ,CAACI,GAAG,CAAC,iBAAiB,CAAC,KAAKb,KAAK,CAACwB,kBAAkB,EAAE;QAChE1B,oBAAoB,CAACkB,iBAAiB,CAAC,CAAC;MAC1C;IACF;;IAEA;IACA,MAAMS,WAAW,GAAGxB,oBAAoB,CAACU,QAAQ,EAAED,WAAW,EAAEE,YAAY,CAAC;IAC7E,MAAMH,QAAQ,CAACiB,cAAc,CAACD,WAAW,CAAC;EAC5C,CAAC;EAAA,OAAApB,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAED,SAASL,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}