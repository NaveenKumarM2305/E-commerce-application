{"ast":null,"code":"/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1, v2) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2);\n  // pop off the patch\n  const p1 = n1.pop();\n  const p2 = n2.pop();\n  // validate numbers\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\nexport const validate = version => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\nexport const compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator);\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  const res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\nexport const satisfies = (version, range) => {\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '=';\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~') return compare(version, range, op);\n  // else range of either \"~\" or \"^\" is assumed\n  const [v1, v2, v3,, vp] = validateAndParse(version);\n  const [r1, r2, r3,, rp] = validateAndParse(range);\n  const v = [v1, v2, v3];\n  const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x'];\n  // validate pre-release\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  }\n  // first non-zero number\n  const nonZero = r.findIndex(v => v !== '0') + 1;\n  // pointer to where segments can be >=\n  const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;\n  // before pointer must be equal\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false;\n  // after pointer must be >=\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n  return true;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\nconst validateAndParse = version => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  const match = version.match(semver);\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n  }\n  match.shift();\n  return match;\n};\nconst isWildcard = s => s === '*' || s === 'x' || s === 'X';\nconst tryParse = v => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n  return 0;\n};\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nconst allowedOperators = Object.keys(operatorResMap);\nconst assertValidOperator = op => {\n  if (typeof op !== 'string') {\n    throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n  }\n};","map":{"version":3,"names":["compareVersions","v1","v2","n1","validateAndParse","n2","p1","pop","p2","r","compareSegments","split","validate","version","test","semver","compare","operator","assertValidOperator","res","operatorResMap","includes","satisfies","range","m","match","op","v3","vp","r1","r2","r3","rp","v","nonZero","findIndex","i","slice","TypeError","Error","shift","isWildcard","s","tryParse","n","parseInt","isNaN","forceType","a","b","String","compareStrings","ap","bp","Math","max","length","allowedOperators","Object","keys","indexOf","join"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/compare-versions/lib/esm/index.js"],"sourcesContent":["/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1, v2) => {\n    // validate input and split into segments\n    const n1 = validateAndParse(v1);\n    const n2 = validateAndParse(v2);\n    // pop off the patch\n    const p1 = n1.pop();\n    const p2 = n2.pop();\n    // validate numbers\n    const r = compareSegments(n1, n2);\n    if (r !== 0)\n        return r;\n    // validate pre-release\n    if (p1 && p2) {\n        return compareSegments(p1.split('.'), p2.split('.'));\n    }\n    else if (p1 || p2) {\n        return p1 ? -1 : 1;\n    }\n    return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\nexport const validate = (version) => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\nexport const compare = (v1, v2, operator) => {\n    // validate input operator\n    assertValidOperator(operator);\n    // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n    const res = compareVersions(v1, v2);\n    return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\nexport const satisfies = (version, range) => {\n    // if no range operator then \"=\"\n    const m = range.match(/^([<>=~^]+)/);\n    const op = m ? m[1] : '=';\n    // if gt/lt/eq then operator compare\n    if (op !== '^' && op !== '~')\n        return compare(version, range, op);\n    // else range of either \"~\" or \"^\" is assumed\n    const [v1, v2, v3, , vp] = validateAndParse(version);\n    const [r1, r2, r3, , rp] = validateAndParse(range);\n    const v = [v1, v2, v3];\n    const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x'];\n    // validate pre-release\n    if (rp) {\n        if (!vp)\n            return false;\n        if (compareSegments(v, r) !== 0)\n            return false;\n        if (compareSegments(vp.split('.'), rp.split('.')) === -1)\n            return false;\n    }\n    // first non-zero number\n    const nonZero = r.findIndex((v) => v !== '0') + 1;\n    // pointer to where segments can be >=\n    const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;\n    // before pointer must be equal\n    if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)\n        return false;\n    // after pointer must be >=\n    if (compareSegments(v.slice(i), r.slice(i)) === -1)\n        return false;\n    return true;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\nconst validateAndParse = (version) => {\n    if (typeof version !== 'string') {\n        throw new TypeError('Invalid argument expected string');\n    }\n    const match = version.match(semver);\n    if (!match) {\n        throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n    }\n    match.shift();\n    return match;\n};\nconst isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\nconst tryParse = (v) => {\n    const n = parseInt(v, 10);\n    return isNaN(n) ? v : n;\n};\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\nconst compareStrings = (a, b) => {\n    if (isWildcard(a) || isWildcard(b))\n        return 0;\n    const [ap, bp] = forceType(tryParse(a), tryParse(b));\n    if (ap > bp)\n        return 1;\n    if (ap < bp)\n        return -1;\n    return 0;\n};\nconst compareSegments = (a, b) => {\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const r = compareStrings(a[i] || '0', b[i] || '0');\n        if (r !== 0)\n            return r;\n    }\n    return 0;\n};\nconst operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1],\n};\nconst allowedOperators = Object.keys(operatorResMap);\nconst assertValidOperator = (op) => {\n    if (typeof op !== 'string') {\n        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n    }\n    if (allowedOperators.indexOf(op) === -1) {\n        throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}