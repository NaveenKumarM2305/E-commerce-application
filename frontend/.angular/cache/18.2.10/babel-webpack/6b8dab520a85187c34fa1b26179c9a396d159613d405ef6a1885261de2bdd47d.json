{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { jsonpath } from '../../../util/jsonpath.js';\nimport AuthSdkError from '../../../errors/AuthSdkError.js';\nimport '../../../errors/WWWAuthError.js';\nconst SKIP_FIELDS = {\n  'remediation': true,\n  'context': true\n};\nconst parseNonRemediations = function parseNonRemediations(authClient, idxResponse, toPersist = {}) {\n  const actions = {};\n  const context = {};\n  Object.keys(idxResponse).filter(field => !SKIP_FIELDS[field]).forEach(field => {\n    const fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n    if (!fieldIsObject) {\n      context[field] = idxResponse[field];\n      return;\n    }\n    if (idxResponse[field].rel) {\n      actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n      return;\n    }\n    const _a = idxResponse[field],\n      {\n        value: fieldValue,\n        type\n      } = _a,\n      info = __rest(_a, [\"value\", \"type\"]);\n    context[field] = Object.assign({\n      type\n    }, info);\n    if (type !== 'object') {\n      context[field].value = fieldValue;\n      return;\n    }\n    context[field].value = {};\n    Object.entries(fieldValue).forEach(([subField, value]) => {\n      if (value.rel) {\n        actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);\n      } else {\n        context[field].value[subField] = value;\n      }\n    });\n  });\n  return {\n    context,\n    actions\n  };\n};\nconst expandRelatesTo = (idxResponse, value) => {\n  Object.keys(value).forEach(k => {\n    if (k === 'relatesTo') {\n      const query = Array.isArray(value[k]) ? value[k][0] : value[k];\n      if (typeof query === 'string') {\n        const result = jsonpath({\n          path: query,\n          json: idxResponse\n        });\n        if (result) {\n          value[k] = result;\n          return;\n        } else {\n          throw new AuthSdkError(`Cannot resolve relatesTo: ${query}`);\n        }\n      }\n    }\n    if (Array.isArray(value[k])) {\n      value[k].forEach(innerValue => expandRelatesTo(idxResponse, innerValue));\n    }\n  });\n};\nconst convertRemediationAction = (authClient, remediation, toPersist) => {\n  if (remediation.rel) {\n    const remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n    const actionFn = remediationActions[remediation.name];\n    return Object.assign(Object.assign({}, remediation), {\n      action: actionFn\n    });\n  }\n  return remediation;\n};\nconst parseIdxResponse = function parseIdxResponse(authClient, idxResponse, toPersist = {}) {\n  var _a;\n  const remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n  remediationData.forEach(remediation => {\n    var _a;\n    if (remediation.name === 'launch-authenticator' && ((_a = remediation === null || remediation === void 0 ? void 0 : remediation.relatesTo) === null || _a === void 0 ? void 0 : _a[0]) === 'authenticatorChallenge' && !(idxResponse === null || idxResponse === void 0 ? void 0 : idxResponse.authenticatorChallenge)) {\n      delete remediation.relatesTo;\n      return;\n    }\n    return expandRelatesTo(idxResponse, remediation);\n  });\n  const remediations = remediationData.map(remediation => convertRemediationAction(authClient, remediation, toPersist));\n  const {\n    context,\n    actions\n  } = parseNonRemediations(authClient, idxResponse, toPersist);\n  return {\n    remediations,\n    context,\n    actions\n  };\n};\nexport { parseIdxResponse, parseNonRemediations };","map":{"version":3,"names":["__rest","generateRemediationFunctions","generateIdxAction","jsonpath","AuthSdkError","SKIP_FIELDS","parseNonRemediations","authClient","idxResponse","toPersist","actions","context","Object","keys","filter","field","forEach","fieldIsObject","rel","name","_a","value","fieldValue","type","info","assign","entries","subField","expandRelatesTo","k","query","Array","isArray","result","path","json","innerValue","convertRemediationAction","remediation","remediationActions","actionFn","action","parseIdxResponse","remediationData","relatesTo","authenticatorChallenge","remediations","map"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/idxResponseParser.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { jsonpath } from '../../../util/jsonpath.js';\nimport AuthSdkError from '../../../errors/AuthSdkError.js';\nimport '../../../errors/WWWAuthError.js';\n\nconst SKIP_FIELDS = {\n    'remediation': true,\n    'context': true,\n};\nconst parseNonRemediations = function parseNonRemediations(authClient, idxResponse, toPersist = {}) {\n    const actions = {};\n    const context = {};\n    Object.keys(idxResponse)\n        .filter(field => !SKIP_FIELDS[field])\n        .forEach(field => {\n        const fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n        if (!fieldIsObject) {\n            context[field] = idxResponse[field];\n            return;\n        }\n        if (idxResponse[field].rel) {\n            actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n            return;\n        }\n        const _a = idxResponse[field], { value: fieldValue, type } = _a, info = __rest(_a, [\"value\", \"type\"]);\n        context[field] = Object.assign({ type }, info);\n        if (type !== 'object') {\n            context[field].value = fieldValue;\n            return;\n        }\n        context[field].value = {};\n        Object.entries(fieldValue)\n            .forEach(([subField, value]) => {\n            if (value.rel) {\n                actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);\n            }\n            else {\n                context[field].value[subField] = value;\n            }\n        });\n    });\n    return { context, actions };\n};\nconst expandRelatesTo = (idxResponse, value) => {\n    Object.keys(value).forEach(k => {\n        if (k === 'relatesTo') {\n            const query = Array.isArray(value[k]) ? value[k][0] : value[k];\n            if (typeof query === 'string') {\n                const result = jsonpath({ path: query, json: idxResponse });\n                if (result) {\n                    value[k] = result;\n                    return;\n                }\n                else {\n                    throw new AuthSdkError(`Cannot resolve relatesTo: ${query}`);\n                }\n            }\n        }\n        if (Array.isArray(value[k])) {\n            value[k].forEach(innerValue => expandRelatesTo(idxResponse, innerValue));\n        }\n    });\n};\nconst convertRemediationAction = (authClient, remediation, toPersist) => {\n    if (remediation.rel) {\n        const remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n        const actionFn = remediationActions[remediation.name];\n        return Object.assign(Object.assign({}, remediation), { action: actionFn });\n    }\n    return remediation;\n};\nconst parseIdxResponse = function parseIdxResponse(authClient, idxResponse, toPersist = {}) {\n    var _a;\n    const remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n    remediationData.forEach(remediation => {\n        var _a;\n        if (remediation.name === 'launch-authenticator' &&\n            ((_a = remediation === null || remediation === void 0 ? void 0 : remediation.relatesTo) === null || _a === void 0 ? void 0 : _a[0]) === 'authenticatorChallenge' &&\n            !(idxResponse === null || idxResponse === void 0 ? void 0 : idxResponse.authenticatorChallenge)) {\n            delete remediation.relatesTo;\n            return;\n        }\n        return expandRelatesTo(idxResponse, remediation);\n    });\n    const remediations = remediationData.map(remediation => convertRemediationAction(authClient, remediation, toPersist));\n    const { context, actions } = parseNonRemediations(authClient, idxResponse, toPersist);\n    return {\n        remediations,\n        context,\n        actions,\n    };\n};\n\nexport { parseIdxResponse, parseNonRemediations };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}