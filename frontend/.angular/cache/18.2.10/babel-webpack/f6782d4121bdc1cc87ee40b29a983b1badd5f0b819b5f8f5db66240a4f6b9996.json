{"ast":null,"code":"import { FORMS } from './RemediationConstants.js';\n\n/*!\n * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\nconst flattenObj = obj => {\n  let result = {};\n  Object.keys(obj).forEach(key => {\n    if (typeof obj[key] !== 'object') {\n      result[key] = obj[key];\n      return;\n    }\n    const tempObj = flattenObj(obj[key]);\n    Object.keys(tempObj).forEach(j => {\n      result[key + '.' + j] = tempObj[j];\n    });\n  });\n  return result;\n};\n\n/**\n * This function is for the Granular Consent remediation, scopes within the optedScopes\n * property can include a singular value or n values delimited by a \".\"\n * When they are delimited, BackBone's toJSON function will create a nested object, however,\n * these should not be nested and the delimited key names should stay as is. So this function will\n * flatten those nested proeprties to format it how the backend expects it. \n * i.e. { optedScopes: { some: { scope: true }}} = { optedScopes: { 'some.scope': true }}\n * Currently, this is only used when the Granular Consent view form is saved see:\n * src/v2/view-builder/views/consent/GranularConsentView.js\n * \n * @param {JSON} modelJSON JSON Equivalent of the Backbone Model's attributes/fields\n * @returns If the JSON contains the optedScopes Property, we will flatten the fields from\n * a nested object into K/V pair with dot notation for nested key names. Otherwise, we will return\n * the JSON as is.\n */\nconst transformOptedScopes = modelJSON => {\n  if (modelJSON.optedScopes && typeof modelJSON.optedScopes !== 'string') {\n    const data = {\n      ...modelJSON,\n      optedScopes: flattenObj(modelJSON.optedScopes)\n    };\n    return data;\n  }\n  return modelJSON;\n};\nconst FormNameToTransformerHandler = {\n  [FORMS.CONSENT_GRANULAR]: transformOptedScopes\n};\n\n/**\n * The purpose of this function is the transform the\n * Backbone Model's attributes/fields into a JSON equivalent before sending to IDX,\n * since the Model fields are all flattend when the UI Schema is transformed on consumption.\n * \n * @param {string} formName Form name of the current remediation\n * @param {Model} model Backbone Model Class\n * @returns JSON equivalent of the Model\n */\nconst transformPayload = (formName, model) => {\n  const modelJSON = model.toJSON();\n  const transformHandler = FormNameToTransformerHandler[formName];\n  if (typeof transformHandler === 'undefined') {\n    return modelJSON;\n  }\n  return transformHandler(modelJSON);\n};\nexport { transformPayload as default };","map":{"version":3,"names":["FORMS","flattenObj","obj","result","Object","keys","forEach","key","tempObj","j","transformOptedScopes","modelJSON","optedScopes","data","FormNameToTransformerHandler","CONSENT_GRANULAR","transformPayload","formName","model","toJSON","transformHandler","default"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/payloadTransformer.js"],"sourcesContent":["import { FORMS } from './RemediationConstants.js';\n\n/*!\n * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\nconst flattenObj = obj => {\n  let result = {};\n  Object.keys(obj).forEach(key => {\n    if (typeof obj[key] !== 'object') {\n      result[key] = obj[key];\n      return;\n    }\n    const tempObj = flattenObj(obj[key]);\n    Object.keys(tempObj).forEach(j => {\n      result[key + '.' + j] = tempObj[j];\n    });\n  });\n  return result;\n};\n\n/**\n * This function is for the Granular Consent remediation, scopes within the optedScopes\n * property can include a singular value or n values delimited by a \".\"\n * When they are delimited, BackBone's toJSON function will create a nested object, however,\n * these should not be nested and the delimited key names should stay as is. So this function will\n * flatten those nested proeprties to format it how the backend expects it. \n * i.e. { optedScopes: { some: { scope: true }}} = { optedScopes: { 'some.scope': true }}\n * Currently, this is only used when the Granular Consent view form is saved see:\n * src/v2/view-builder/views/consent/GranularConsentView.js\n * \n * @param {JSON} modelJSON JSON Equivalent of the Backbone Model's attributes/fields\n * @returns If the JSON contains the optedScopes Property, we will flatten the fields from\n * a nested object into K/V pair with dot notation for nested key names. Otherwise, we will return\n * the JSON as is.\n */\nconst transformOptedScopes = modelJSON => {\n  if (modelJSON.optedScopes && typeof modelJSON.optedScopes !== 'string') {\n    const data = {\n      ...modelJSON,\n      optedScopes: flattenObj(modelJSON.optedScopes)\n    };\n    return data;\n  }\n  return modelJSON;\n};\nconst FormNameToTransformerHandler = {\n  [FORMS.CONSENT_GRANULAR]: transformOptedScopes\n};\n\n/**\n * The purpose of this function is the transform the\n * Backbone Model's attributes/fields into a JSON equivalent before sending to IDX,\n * since the Model fields are all flattend when the UI Schema is transformed on consumption.\n * \n * @param {string} formName Form name of the current remediation\n * @param {Model} model Backbone Model Class\n * @returns JSON equivalent of the Model\n */\nconst transformPayload = (formName, model) => {\n  const modelJSON = model.toJSON();\n  const transformHandler = FormNameToTransformerHandler[formName];\n  if (typeof transformHandler === 'undefined') {\n    return modelJSON;\n  }\n  return transformHandler(modelJSON);\n};\n\nexport { transformPayload as default };\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,2BAA2B;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAGC,GAAG,IAAI;EACxB,IAAIC,MAAM,GAAG,CAAC,CAAC;EACfC,MAAM,CAACC,IAAI,CAACH,GAAG,CAAC,CAACI,OAAO,CAACC,GAAG,IAAI;IAC9B,IAAI,OAAOL,GAAG,CAACK,GAAG,CAAC,KAAK,QAAQ,EAAE;MAChCJ,MAAM,CAACI,GAAG,CAAC,GAAGL,GAAG,CAACK,GAAG,CAAC;MACtB;IACF;IACA,MAAMC,OAAO,GAAGP,UAAU,CAACC,GAAG,CAACK,GAAG,CAAC,CAAC;IACpCH,MAAM,CAACC,IAAI,CAACG,OAAO,CAAC,CAACF,OAAO,CAACG,CAAC,IAAI;MAChCN,MAAM,CAACI,GAAG,GAAG,GAAG,GAAGE,CAAC,CAAC,GAAGD,OAAO,CAACC,CAAC,CAAC;IACpC,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAON,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,oBAAoB,GAAGC,SAAS,IAAI;EACxC,IAAIA,SAAS,CAACC,WAAW,IAAI,OAAOD,SAAS,CAACC,WAAW,KAAK,QAAQ,EAAE;IACtE,MAAMC,IAAI,GAAG;MACX,GAAGF,SAAS;MACZC,WAAW,EAAEX,UAAU,CAACU,SAAS,CAACC,WAAW;IAC/C,CAAC;IACD,OAAOC,IAAI;EACb;EACA,OAAOF,SAAS;AAClB,CAAC;AACD,MAAMG,4BAA4B,GAAG;EACnC,CAACd,KAAK,CAACe,gBAAgB,GAAGL;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,gBAAgB,GAAGA,CAACC,QAAQ,EAAEC,KAAK,KAAK;EAC5C,MAAMP,SAAS,GAAGO,KAAK,CAACC,MAAM,CAAC,CAAC;EAChC,MAAMC,gBAAgB,GAAGN,4BAA4B,CAACG,QAAQ,CAAC;EAC/D,IAAI,OAAOG,gBAAgB,KAAK,WAAW,EAAE;IAC3C,OAAOT,SAAS;EAClB;EACA,OAAOS,gBAAgB,CAACT,SAAS,CAAC;AACpC,CAAC;AAED,SAASK,gBAAgB,IAAIK,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}