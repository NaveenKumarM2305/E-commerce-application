{"ast":null,"code":"import toMilliseconds from '@sindresorhus/to-milliseconds';\nimport parseMs from 'parse-ms';\nconst MOMENT_UNIT = {\n  MILLISECOND: 'milliseconds',\n  SECOND: 'seconds',\n  MINUTE: 'minutes',\n  HOUR: 'hours',\n  DAY: 'days'\n};\nconst MOMENT_UNIT_KEYS = Object.keys(MOMENT_UNIT);\n\n/**\n * @method convertMomentUnits\n * Conversion between moment's units and our units internally\n *\n * @param {String} momentUnit The units that val is in\n * @return {String} The key in the MOMENT_UNIT hash\n */\nconst convertMomentUnits = function (momentUnit) {\n  const entry = MOMENT_UNIT_KEYS.filter(k => MOMENT_UNIT[k] === momentUnit);\n  return entry.length === 1 ? entry[0] : momentUnit;\n};\nvar TimeUtil = {\n  /**\n   * @method getTimeInHighestRelevantUnit\n   * Will return a number in the units of the highest relevant time unit.\n   * Only checks milliseconds, seconds, minutes, hours, and days.\n   * E.g.\n   *   15 MINUTE  -> 15 MINUTE\n   *   15 minutes -> 15 MINUTE\n   *   60 minutes ->  1 HOUR\n   *   90 minutes -> 90 MINUTE\n   *   24 HOUR    ->  1 DAY\n   *   24 hours   ->  1 DAY\n   *   30 DAY     -> 30 DAY\n   *\n   * @typedef { \"MILLISECOND\" | \"SECOND\" | \"MINUTE\" | \"HOUR\" | \"DAY\" } TimeUnit\n   *\n   * @typedef { \"MILLISECOND\" | \"SECOND\" | \"MINUTE\" | \"HOUR\" | \"DAY\" |\n   *            \"milliseconds\" | \"seconds\" | \"minutes\" | \"hours\" | \"days\"\n   *          } FlexibleTimeUnit\n   *\n   * @typedef TimeAndUnit\n   * @property {number} time the consolidated time\n   * @property {TimeUnit} unit the unit of the time\n   *\n   * @param {FlexibleTimeUnit} unit The time unit\n   * @return {TimeAndUnit} An object containing the amount of time and the unit\n   */\n  getTimeInHighestRelevantUnit: function (val, unit) {\n    const defaultTimeObj = {\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0\n    };\n    const normalizedUnit = MOMENT_UNIT[unit] || unit;\n    let timeObj;\n    try {\n      const ms = toMilliseconds(Object.assign(defaultTimeObj, {\n        [normalizedUnit]: val\n      }));\n      timeObj = parseMs(ms);\n    } catch (error) {\n      timeObj = {};\n    }\n    const duration = Object.keys(timeObj).reduce((init, k) => {\n      if (timeObj[k] !== 0) {\n        init[k] = timeObj[k];\n      }\n      return init;\n    }, {});\n    let highestUnit;\n    let time;\n    if (Object.keys(duration).length === 1) {\n      Object.keys(duration).forEach(k => {\n        time = duration[k];\n        highestUnit = k;\n      });\n    } else {\n      time = val;\n      highestUnit = normalizedUnit;\n    }\n    return {\n      time: time,\n      unit: convertMomentUnits(highestUnit)\n    };\n  },\n  /**\n   * @method formatDateToDeviceAssuranceGracePeriodExpiryLocaleString\n   * Conversion from a Date object to a locale string that mimics Okta's `short-with-timezone` format\n   * but rounded down to the nearest hour\n   * e.g. new Date(2024-09-05T00:00:00.000Z) -> 09/05/2024, 8:00 PM EDT\n   *\n   * @param {Date} date The Date object for the grace period expiry\n   * @param {LanguageCode} languageCode The user's language code / locale\n   * @return {string} The formatted `short-with-timezone` local string\n   */\n  formatDateToDeviceAssuranceGracePeriodExpiryLocaleString: (date, languageCode) => {\n    try {\n      // Invalid Date objects will return NaN for valueOf()\n      if (date && !isNaN(date.valueOf()) && languageCode !== null) {\n        // Round down the date to the nearest hour\n        date.setMinutes(0, 0, 0);\n        return date.toLocaleString(languageCode, {\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n          hour: '2-digit',\n          minute: '2-digit',\n          timeZoneName: 'short'\n        });\n      } else {\n        return null;\n      }\n    } catch (e) {\n      // If `languageCode` isn't in a valid format `toLocaleString()` will throw a `RangeError`\n      return null;\n    }\n  }\n};\nexport { TimeUtil as default };","map":{"version":3,"names":["toMilliseconds","parseMs","MOMENT_UNIT","MILLISECOND","SECOND","MINUTE","HOUR","DAY","MOMENT_UNIT_KEYS","Object","keys","convertMomentUnits","momentUnit","entry","filter","k","length","TimeUtil","getTimeInHighestRelevantUnit","val","unit","defaultTimeObj","days","hours","minutes","seconds","milliseconds","normalizedUnit","timeObj","ms","assign","error","duration","reduce","init","highestUnit","time","forEach","formatDateToDeviceAssuranceGracePeriodExpiryLocaleString","date","languageCode","isNaN","valueOf","setMinutes","toLocaleString","year","month","day","hour","minute","timeZoneName","e","default"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/util/TimeUtil.js"],"sourcesContent":["import toMilliseconds from '@sindresorhus/to-milliseconds';\nimport parseMs from 'parse-ms';\n\nconst MOMENT_UNIT = {\n  MILLISECOND: 'milliseconds',\n  SECOND: 'seconds',\n  MINUTE: 'minutes',\n  HOUR: 'hours',\n  DAY: 'days'\n};\nconst MOMENT_UNIT_KEYS = Object.keys(MOMENT_UNIT);\n\n/**\n * @method convertMomentUnits\n * Conversion between moment's units and our units internally\n *\n * @param {String} momentUnit The units that val is in\n * @return {String} The key in the MOMENT_UNIT hash\n */\nconst convertMomentUnits = function (momentUnit) {\n  const entry = MOMENT_UNIT_KEYS.filter(k => MOMENT_UNIT[k] === momentUnit);\n  return entry.length === 1 ? entry[0] : momentUnit;\n};\nvar TimeUtil = {\n  /**\n   * @method getTimeInHighestRelevantUnit\n   * Will return a number in the units of the highest relevant time unit.\n   * Only checks milliseconds, seconds, minutes, hours, and days.\n   * E.g.\n   *   15 MINUTE  -> 15 MINUTE\n   *   15 minutes -> 15 MINUTE\n   *   60 minutes ->  1 HOUR\n   *   90 minutes -> 90 MINUTE\n   *   24 HOUR    ->  1 DAY\n   *   24 hours   ->  1 DAY\n   *   30 DAY     -> 30 DAY\n   *\n   * @typedef { \"MILLISECOND\" | \"SECOND\" | \"MINUTE\" | \"HOUR\" | \"DAY\" } TimeUnit\n   *\n   * @typedef { \"MILLISECOND\" | \"SECOND\" | \"MINUTE\" | \"HOUR\" | \"DAY\" |\n   *            \"milliseconds\" | \"seconds\" | \"minutes\" | \"hours\" | \"days\"\n   *          } FlexibleTimeUnit\n   *\n   * @typedef TimeAndUnit\n   * @property {number} time the consolidated time\n   * @property {TimeUnit} unit the unit of the time\n   *\n   * @param {FlexibleTimeUnit} unit The time unit\n   * @return {TimeAndUnit} An object containing the amount of time and the unit\n   */\n  getTimeInHighestRelevantUnit: function (val, unit) {\n    const defaultTimeObj = {\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0\n    };\n    const normalizedUnit = MOMENT_UNIT[unit] || unit;\n    let timeObj;\n    try {\n      const ms = toMilliseconds(Object.assign(defaultTimeObj, {\n        [normalizedUnit]: val\n      }));\n      timeObj = parseMs(ms);\n    } catch (error) {\n      timeObj = {};\n    }\n    const duration = Object.keys(timeObj).reduce((init, k) => {\n      if (timeObj[k] !== 0) {\n        init[k] = timeObj[k];\n      }\n      return init;\n    }, {});\n    let highestUnit;\n    let time;\n    if (Object.keys(duration).length === 1) {\n      Object.keys(duration).forEach(k => {\n        time = duration[k];\n        highestUnit = k;\n      });\n    } else {\n      time = val;\n      highestUnit = normalizedUnit;\n    }\n    return {\n      time: time,\n      unit: convertMomentUnits(highestUnit)\n    };\n  },\n  /**\n   * @method formatDateToDeviceAssuranceGracePeriodExpiryLocaleString\n   * Conversion from a Date object to a locale string that mimics Okta's `short-with-timezone` format\n   * but rounded down to the nearest hour\n   * e.g. new Date(2024-09-05T00:00:00.000Z) -> 09/05/2024, 8:00 PM EDT\n   *\n   * @param {Date} date The Date object for the grace period expiry\n   * @param {LanguageCode} languageCode The user's language code / locale\n   * @return {string} The formatted `short-with-timezone` local string\n   */\n  formatDateToDeviceAssuranceGracePeriodExpiryLocaleString: (date, languageCode) => {\n    try {\n      // Invalid Date objects will return NaN for valueOf()\n      if (date && !isNaN(date.valueOf()) && languageCode !== null) {\n        // Round down the date to the nearest hour\n        date.setMinutes(0, 0, 0);\n        return date.toLocaleString(languageCode, {\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n          hour: '2-digit',\n          minute: '2-digit',\n          timeZoneName: 'short'\n        });\n      } else {\n        return null;\n      }\n    } catch (e) {\n      // If `languageCode` isn't in a valid format `toLocaleString()` will throw a `RangeError`\n      return null;\n    }\n  }\n};\n\nexport { TimeUtil as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}