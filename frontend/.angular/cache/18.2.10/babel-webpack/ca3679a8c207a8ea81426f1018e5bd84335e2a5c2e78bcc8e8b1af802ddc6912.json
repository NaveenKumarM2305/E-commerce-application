{"ast":null,"code":"import '../../../../packages/@okta/courage-dist/esm/src/CourageForSigninWidget.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/framework/Model.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/vendor/lib/backbone.js';\nimport oktaJQueryStatic from '../../../../packages/@okta/courage-dist/esm/src/courage/util/jquery-wrapper.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/util/underscore-wrapper.js';\nimport '../../../../packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars.runtime.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/models/Model.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/models/BaseModel.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/framework/View.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/views/Backbone.ListView.js';\nimport './BaseHeader.js';\nimport './BaseFooter.js';\nimport './BaseForm.js';\nimport BaseFormWithPolling from './BaseFormWithPolling.js';\nimport './BaseView.js';\nimport '../components/AuthenticatorEnrollOptions.js';\nimport '../components/AuthenticatorVerifyOptions.js';\nimport '../../../../packages/@okta/courage-dist/esm/lib/underscore/underscore-min.js';\nimport 'cross-fetch';\nimport fn from '../../../util/BrowserFeatures.js';\nimport Logger from '../../../util/Logger.js';\nimport '../../../util/FactorUtil.js';\nimport '../../../v1/views/admin-consent/ScopeList.js';\nimport '../../../v1/views/consent/ScopeList.js';\nimport '../views/captcha/CaptchaView.js';\nimport { AUTHENTICATOR_CANCEL_ACTION, AUTHENTICATION_CANCEL_REASONS, CHALLENGE_TIMEOUT } from '../utils/Constants.js';\nimport { doChallenge, createInvisibleIFrame, cancelPollingWithParams } from '../utils/ChallengeViewUtil.js';\n\n/* eslint max-statements: [2, 22] */\nconst request = opts => {\n  const ajaxOptions = Object.assign({\n    method: 'GET',\n    contentType: 'application/json'\n  }, opts);\n  return oktaJQueryStatic.ajax(ajaxOptions);\n};\nconst Body = BaseFormWithPolling.extend({\n  noButtonBar: true,\n  className: 'ion-form device-challenge-poll',\n  events: {\n    'click #launch-ov': function (e) {\n      e.preventDefault();\n      this.doCustomURI();\n    }\n  },\n  pollingCancelAction: AUTHENTICATOR_CANCEL_ACTION,\n  initialize: function () {\n    BaseFormWithPolling.prototype.initialize.apply(this, arguments);\n    this.listenTo(this.model, 'error', this.onPollingFail);\n    this.doChallenge();\n    this.startPolling();\n  },\n  doChallenge: function () {\n    doChallenge(this);\n  },\n  onPollingFail: function () {\n    this.$('.spinner').hide();\n    this.stopPolling();\n  },\n  remove: function () {\n    BaseFormWithPolling.prototype.remove.apply(this, arguments);\n    this.stopProbing();\n    this.stopPolling();\n  },\n  getDeviceChallengePayload: function () {\n    throw new Error('getDeviceChallengePayload needs to be implemented');\n  },\n  doLoopback: function (deviceChallenge) {\n    let authenticatorDomainUrl = deviceChallenge.domain !== undefined ? deviceChallenge.domain : '';\n    let authenticatorHttpsDomainUrl = deviceChallenge.httpsDomain !== undefined ? deviceChallenge.httpsDomain : '';\n    let ports = deviceChallenge.ports !== undefined ? deviceChallenge.ports : [];\n    let maxNumberOfPorts = ports.length;\n    let challengeRequest = deviceChallenge.challengeRequest !== undefined ? deviceChallenge.challengeRequest : '';\n    let probeTimeoutMillis = deviceChallenge.probeTimeoutMillis !== undefined ? deviceChallenge.probeTimeoutMillis : 100;\n    let currentPort;\n    let foundPort = false;\n    let ovFailed = false;\n    let countFailedPorts = 0;\n    const getAuthenticatorUrl = (path, domainUrl) => {\n      return `${domainUrl}:${currentPort}/${path}`;\n    };\n    const checkPort = url => {\n      return request({\n        url: url,\n        /*\n        OKTA-278573 in loopback server, SSL handshake sometimes takes more than 100ms and thus needs additional\n        timeout however, increasing timeout is a temporary solution since user will need to wait much longer in\n        worst case.\n        TODO: Android timeout is temporarily set to 3000ms and needs optimization post-Beta.\n        OKTA-365427 introduces probeTimeoutMillis; but we should also consider probeTimeoutMillisHTTPS for\n        customizing timeouts in the more costly Android and other (keyless) HTTPS scenarios.\n        */\n        timeout: fn.isAndroid() ? 3000 : probeTimeoutMillis\n      });\n    };\n    const onPortFound = url => {\n      return request({\n        url: url,\n        method: 'POST',\n        data: JSON.stringify({\n          challengeRequest: challengeRequest\n        }),\n        timeout: CHALLENGE_TIMEOUT // authenticator should respond within 5 min (300000ms) for challenge request\n      });\n    };\n    const onFailure = () => {\n      Logger.error(`Something unexpected happened while we were checking port ${currentPort}.`);\n      return oktaJQueryStatic.Deferred().reject();\n    };\n    const doProbing = domainUrl => {\n      return checkPort(getAuthenticatorUrl('probe', domainUrl)).then(() => {\n        return onPortFound(getAuthenticatorUrl('challenge', domainUrl)).then(() => {\n          foundPort = true;\n          if (deviceChallenge.enhancedPollingEnabled !== false) {\n            // this way we can gurantee that\n            // 1. the polling is triggered right away (1ms interval)\n            // 2. Only one polling queue\n            // 3. follwoing polling will continue with refresh interval from previous polling response\n            // NOTE: technically, there could still be concurrency issue where when we called stopPolling,\n            // there is already a polling triggered and hasn't completed yet\n            // but the possibility would be much smaller than previous concurrency issue\n            // this is a best effort change\n            this.stopPolling();\n            this.startPolling(1);\n            return;\n          }\n          // once the OV challenge succeeds,\n          // triggers another polling right away without waiting for the next ongoing polling to be triggered\n          // to make the authentication flow goes faster \n          return this.trigger('save', this.model);\n        }).catch(xhr => {\n          countFailedPorts++;\n          // Windows and MacOS return status code 503 when \n          // there are multiple profiles on the device and\n          // the wrong OS profile responds to the challenge request\n          if (xhr.status !== 503) {\n            // when challenge responds with other errors,\n            // - stop the remaining probing\n            ovFailed = true;\n            // - cancel polling right away\n            cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.OV_ERROR, xhr.status);\n          } else if (countFailedPorts === maxNumberOfPorts) {\n            // when challenge is responded by the wrong OS profile and\n            // all the ports are exhausted,\n            // cancel the polling like the probing has failed\n            cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.LOOPBACK_FAILURE, null);\n          }\n        });\n      }).catch(onFailure);\n    };\n    let probeChain = Promise.resolve();\n    const handlePortProbing = (port, baseUrl, checkPortMaxFailure) => {\n      probeChain = probeChain.then(() => {\n        if (!(foundPort || ovFailed)) {\n          currentPort = port;\n          return doProbing(baseUrl);\n        }\n      }).catch(() => {\n        countFailedPorts++;\n        Logger.error(`Authenticator is not listening on port ${currentPort}.`);\n        if (checkPortMaxFailure && countFailedPorts === maxNumberOfPorts) {\n          Logger.error('No available ports. Loopback server failed and polling is cancelled.');\n          // When no port is found, cancel the polling as well\n          // This is to avoid concurrency issue where /poll/cancel takes long time to complete\n          // and SIW will receive 400 error if the polling continues\n          this.stopPolling();\n          cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.LOOPBACK_FAILURE, null);\n        }\n      });\n    };\n\n    // If https domain exists, do https domain probe first\n    // This only applies to MacOS for now\n    if (authenticatorHttpsDomainUrl) {\n      // if https domain are included, max number of ports to be probed should be doubled\n      Logger.info('httpsDomain enabled, will probe and challenge https first');\n      maxNumberOfPorts += maxNumberOfPorts;\n      ports.forEach(port => {\n        handlePortProbing(port, authenticatorHttpsDomainUrl, false);\n      });\n    }\n\n    // Always do probe on regular domain\n    ports.forEach(port => {\n      handlePortProbing(port, authenticatorDomainUrl, true);\n    });\n  },\n  doCustomURI: function () {\n    this.ulDom && this.ulDom.remove();\n    const IframeView = createInvisibleIFrame('custom-uri-container', this.customURI);\n    this.ulDom = this.add(IframeView).last();\n  },\n  doChromeDTC: function (deviceChallenge) {\n    this.ulDom && this.ulDom.remove();\n    const IframeView = createInvisibleIFrame('chrome-dtc-container', deviceChallenge.href);\n    this.ulDom = this.add(IframeView).last();\n  },\n  stopProbing: function () {\n    this.checkPortXhr && this.checkPortXhr.abort();\n    this.probingXhr && this.probingXhr.abort();\n  }\n});\nexport { Body as default };","map":{"version":3,"names":["oktaJQueryStatic","BaseFormWithPolling","fn","Logger","AUTHENTICATOR_CANCEL_ACTION","AUTHENTICATION_CANCEL_REASONS","CHALLENGE_TIMEOUT","doChallenge","createInvisibleIFrame","cancelPollingWithParams","request","opts","ajaxOptions","Object","assign","method","contentType","ajax","Body","extend","noButtonBar","className","events","click #launch-ov","e","preventDefault","doCustomURI","pollingCancelAction","initialize","prototype","apply","arguments","listenTo","model","onPollingFail","startPolling","$","hide","stopPolling","remove","stopProbing","getDeviceChallengePayload","Error","doLoopback","deviceChallenge","authenticatorDomainUrl","domain","undefined","authenticatorHttpsDomainUrl","httpsDomain","ports","maxNumberOfPorts","length","challengeRequest","probeTimeoutMillis","currentPort","foundPort","ovFailed","countFailedPorts","getAuthenticatorUrl","path","domainUrl","checkPort","url","timeout","isAndroid","onPortFound","data","JSON","stringify","onFailure","error","Deferred","reject","doProbing","then","enhancedPollingEnabled","trigger","catch","xhr","status","options","appState","OV_ERROR","LOOPBACK_FAILURE","probeChain","Promise","resolve","handlePortProbing","port","baseUrl","checkPortMaxFailure","info","forEach","ulDom","IframeView","customURI","add","last","doChromeDTC","href","checkPortXhr","abort","probingXhr","default"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseOktaVerifyChallengeView.js"],"sourcesContent":["import '../../../../packages/@okta/courage-dist/esm/src/CourageForSigninWidget.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/framework/Model.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/vendor/lib/backbone.js';\nimport oktaJQueryStatic from '../../../../packages/@okta/courage-dist/esm/src/courage/util/jquery-wrapper.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/util/underscore-wrapper.js';\nimport '../../../../packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars.runtime.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/models/Model.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/models/BaseModel.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/framework/View.js';\nimport '../../../../packages/@okta/courage-dist/esm/src/courage/views/Backbone.ListView.js';\nimport './BaseHeader.js';\nimport './BaseFooter.js';\nimport './BaseForm.js';\nimport BaseFormWithPolling from './BaseFormWithPolling.js';\nimport './BaseView.js';\nimport '../components/AuthenticatorEnrollOptions.js';\nimport '../components/AuthenticatorVerifyOptions.js';\nimport '../../../../packages/@okta/courage-dist/esm/lib/underscore/underscore-min.js';\nimport 'cross-fetch';\nimport fn from '../../../util/BrowserFeatures.js';\nimport Logger from '../../../util/Logger.js';\nimport '../../../util/FactorUtil.js';\nimport '../../../v1/views/admin-consent/ScopeList.js';\nimport '../../../v1/views/consent/ScopeList.js';\nimport '../views/captcha/CaptchaView.js';\nimport { AUTHENTICATOR_CANCEL_ACTION, AUTHENTICATION_CANCEL_REASONS, CHALLENGE_TIMEOUT } from '../utils/Constants.js';\nimport { doChallenge, createInvisibleIFrame, cancelPollingWithParams } from '../utils/ChallengeViewUtil.js';\n\n/* eslint max-statements: [2, 22] */\nconst request = opts => {\n  const ajaxOptions = Object.assign({\n    method: 'GET',\n    contentType: 'application/json'\n  }, opts);\n  return oktaJQueryStatic.ajax(ajaxOptions);\n};\nconst Body = BaseFormWithPolling.extend({\n  noButtonBar: true,\n  className: 'ion-form device-challenge-poll',\n  events: {\n    'click #launch-ov': function (e) {\n      e.preventDefault();\n      this.doCustomURI();\n    }\n  },\n  pollingCancelAction: AUTHENTICATOR_CANCEL_ACTION,\n  initialize: function () {\n    BaseFormWithPolling.prototype.initialize.apply(this, arguments);\n    this.listenTo(this.model, 'error', this.onPollingFail);\n    this.doChallenge();\n    this.startPolling();\n  },\n  doChallenge: function () {\n    doChallenge(this);\n  },\n  onPollingFail: function () {\n    this.$('.spinner').hide();\n    this.stopPolling();\n  },\n  remove: function () {\n    BaseFormWithPolling.prototype.remove.apply(this, arguments);\n    this.stopProbing();\n    this.stopPolling();\n  },\n  getDeviceChallengePayload: function () {\n    throw new Error('getDeviceChallengePayload needs to be implemented');\n  },\n  doLoopback: function (deviceChallenge) {\n    let authenticatorDomainUrl = deviceChallenge.domain !== undefined ? deviceChallenge.domain : '';\n    let authenticatorHttpsDomainUrl = deviceChallenge.httpsDomain !== undefined ? deviceChallenge.httpsDomain : '';\n    let ports = deviceChallenge.ports !== undefined ? deviceChallenge.ports : [];\n    let maxNumberOfPorts = ports.length;\n    let challengeRequest = deviceChallenge.challengeRequest !== undefined ? deviceChallenge.challengeRequest : '';\n    let probeTimeoutMillis = deviceChallenge.probeTimeoutMillis !== undefined ? deviceChallenge.probeTimeoutMillis : 100;\n    let currentPort;\n    let foundPort = false;\n    let ovFailed = false;\n    let countFailedPorts = 0;\n    const getAuthenticatorUrl = (path, domainUrl) => {\n      return `${domainUrl}:${currentPort}/${path}`;\n    };\n    const checkPort = url => {\n      return request({\n        url: url,\n        /*\n        OKTA-278573 in loopback server, SSL handshake sometimes takes more than 100ms and thus needs additional\n        timeout however, increasing timeout is a temporary solution since user will need to wait much longer in\n        worst case.\n        TODO: Android timeout is temporarily set to 3000ms and needs optimization post-Beta.\n        OKTA-365427 introduces probeTimeoutMillis; but we should also consider probeTimeoutMillisHTTPS for\n        customizing timeouts in the more costly Android and other (keyless) HTTPS scenarios.\n        */\n        timeout: fn.isAndroid() ? 3000 : probeTimeoutMillis\n      });\n    };\n    const onPortFound = url => {\n      return request({\n        url: url,\n        method: 'POST',\n        data: JSON.stringify({\n          challengeRequest: challengeRequest\n        }),\n        timeout: CHALLENGE_TIMEOUT // authenticator should respond within 5 min (300000ms) for challenge request\n      });\n    };\n\n    const onFailure = () => {\n      Logger.error(`Something unexpected happened while we were checking port ${currentPort}.`);\n      return oktaJQueryStatic.Deferred().reject();\n    };\n    const doProbing = domainUrl => {\n      return checkPort(getAuthenticatorUrl('probe', domainUrl)).then(() => {\n        return onPortFound(getAuthenticatorUrl('challenge', domainUrl)).then(() => {\n          foundPort = true;\n          if (deviceChallenge.enhancedPollingEnabled !== false) {\n            // this way we can gurantee that\n            // 1. the polling is triggered right away (1ms interval)\n            // 2. Only one polling queue\n            // 3. follwoing polling will continue with refresh interval from previous polling response\n            // NOTE: technically, there could still be concurrency issue where when we called stopPolling,\n            // there is already a polling triggered and hasn't completed yet\n            // but the possibility would be much smaller than previous concurrency issue\n            // this is a best effort change\n            this.stopPolling();\n            this.startPolling(1);\n            return;\n          }\n          // once the OV challenge succeeds,\n          // triggers another polling right away without waiting for the next ongoing polling to be triggered\n          // to make the authentication flow goes faster \n          return this.trigger('save', this.model);\n        }).catch(xhr => {\n          countFailedPorts++;\n          // Windows and MacOS return status code 503 when \n          // there are multiple profiles on the device and\n          // the wrong OS profile responds to the challenge request\n          if (xhr.status !== 503) {\n            // when challenge responds with other errors,\n            // - stop the remaining probing\n            ovFailed = true;\n            // - cancel polling right away\n            cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.OV_ERROR, xhr.status);\n          } else if (countFailedPorts === maxNumberOfPorts) {\n            // when challenge is responded by the wrong OS profile and\n            // all the ports are exhausted,\n            // cancel the polling like the probing has failed\n            cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.LOOPBACK_FAILURE, null);\n          }\n        });\n      }).catch(onFailure);\n    };\n    let probeChain = Promise.resolve();\n    const handlePortProbing = (port, baseUrl, checkPortMaxFailure) => {\n      probeChain = probeChain.then(() => {\n        if (!(foundPort || ovFailed)) {\n          currentPort = port;\n          return doProbing(baseUrl);\n        }\n      }).catch(() => {\n        countFailedPorts++;\n        Logger.error(`Authenticator is not listening on port ${currentPort}.`);\n        if (checkPortMaxFailure && countFailedPorts === maxNumberOfPorts) {\n          Logger.error('No available ports. Loopback server failed and polling is cancelled.');\n          // When no port is found, cancel the polling as well\n          // This is to avoid concurrency issue where /poll/cancel takes long time to complete\n          // and SIW will receive 400 error if the polling continues\n          this.stopPolling();\n          cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.LOOPBACK_FAILURE, null);\n        }\n      });\n    };\n\n    // If https domain exists, do https domain probe first\n    // This only applies to MacOS for now\n    if (authenticatorHttpsDomainUrl) {\n      // if https domain are included, max number of ports to be probed should be doubled\n      Logger.info('httpsDomain enabled, will probe and challenge https first');\n      maxNumberOfPorts += maxNumberOfPorts;\n      ports.forEach(port => {\n        handlePortProbing(port, authenticatorHttpsDomainUrl, false);\n      });\n    }\n\n    // Always do probe on regular domain\n    ports.forEach(port => {\n      handlePortProbing(port, authenticatorDomainUrl, true);\n    });\n  },\n  doCustomURI: function () {\n    this.ulDom && this.ulDom.remove();\n    const IframeView = createInvisibleIFrame('custom-uri-container', this.customURI);\n    this.ulDom = this.add(IframeView).last();\n  },\n  doChromeDTC: function (deviceChallenge) {\n    this.ulDom && this.ulDom.remove();\n    const IframeView = createInvisibleIFrame('chrome-dtc-container', deviceChallenge.href);\n    this.ulDom = this.add(IframeView).last();\n  },\n  stopProbing: function () {\n    this.checkPortXhr && this.checkPortXhr.abort();\n    this.probingXhr && this.probingXhr.abort();\n  }\n});\n\nexport { Body as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}