{"ast":null,"code":"import oktaUnderscore from '../../../util/underscore-wrapper.js';\nimport StringUtil from '../../../util/StringUtil.js';\nconst FIELD_REGEX = /^([\\S]+): (.+)$/;\nvar ErrorParser = {\n  /**\n   * Helper function that returns the json output of an xhr objext\n   * @param  {jqXhr} xhr\n   * @return {Object}\n   */\n  getResponseJSON: function (xhr) {\n    try {\n      return xhr.responseJSON || JSON.parse(xhr.responseText);\n    } catch (e) {// ignore error\n    }\n  },\n  /**\n   * Parses an error summary to extract a field name and an error message\n   * @param  {String} errorSummary The raw error summary\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorSummary: function (errorSummary) {\n    const matches = errorSummary.match(FIELD_REGEX); // error format is: `fieldName: The field cannot be left blank`\n\n    if (matches) {\n      return [matches[1], matches[2]];\n    }\n  },\n  /**\n   * Parses an error cause object to extract a field name from property attribute\n   * and an error message form errorSummary attribute. It looks to see if there is\n   * a custom override/translation for the erorrCause.reason before using the errorSummary\n   * @param  {Object} errorCause object\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorCauseObject: function (errorCause) {\n    if (errorCause.property && errorCause.errorSummary) {\n      // avoid triggering sentry log for error event with no cause reason\n      const localizedMsg = errorCause.reason ? StringUtil.localize(errorCause.reason) : undefined;\n      const apiMsg = errorCause.errorSummary;\n      const field = errorCause.property;\n      const errorMessage = (localizedMsg === null || localizedMsg === void 0 ? void 0 : localizedMsg.indexOf('L10N_ERROR[')) === -1 ? localizedMsg : apiMsg;\n      return [field, errorMessage];\n    }\n  },\n  parseErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    return oktaUnderscore.map(responseJSON && responseJSON.errorCauses || [], function (errorCause) {\n      return ('' + errorCause.errorSummary).replace(FIELD_REGEX, '$2');\n    });\n  },\n  /**\n   * Parses the response for errors\n   * Returns a map of field names > array or error messages\n   * Example:\n   * ```javascript\n   * {\n   *   url: ['The field cannot be left blank', 'The field has to be a valid URI'],\n   *   name: ['The field cannot be left blank']\n   * }\n   * ```\n   * @param  {Object} resp\n   * @return {Object}\n   */\n  parseFieldErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    const errors = {}; // xhr error object\n\n    if (responseJSON) {\n      /* eslint complexity: [2, 9] */\n      oktaUnderscore.each(responseJSON.errorCauses || [], function (cause) {\n        let res = [];\n        if (cause.property && cause.errorSummary) {\n          res = this.parseErrorCauseObject(cause);\n        } else if (cause.location && cause.errorSummary) {\n          // To handle new api error format for field level errors.\n          // Ignoring the reason attribute as the translation happens in the API layer and not in the client any more.\n          res = [cause.location, cause.errorSummary];\n        } else {\n          res = this.parseErrorSummary(cause && cause.errorSummary || '');\n        }\n        if (res) {\n          const fieldName = res[0];\n          const message = res[1];\n          errors[fieldName] || (errors[fieldName] = []);\n          errors[fieldName].push(message);\n        }\n      }, this);\n    } // validation key/value object\n    else if (oktaUnderscore.isObject(resp) && oktaUnderscore.size(resp)) {\n      oktaUnderscore.each(resp, function (msg, field) {\n        errors[field] = [msg];\n      });\n    }\n    return oktaUnderscore.size(errors) ? errors : undefined;\n  }\n};\nexport { ErrorParser as default };","map":{"version":3,"names":["oktaUnderscore","StringUtil","FIELD_REGEX","ErrorParser","getResponseJSON","xhr","responseJSON","JSON","parse","responseText","e","parseErrorSummary","errorSummary","matches","match","parseErrorCauseObject","errorCause","property","localizedMsg","reason","localize","undefined","apiMsg","field","errorMessage","indexOf","parseErrors","resp","map","errorCauses","replace","parseFieldErrors","errors","each","cause","res","location","fieldName","message","push","isObject","size","msg","default"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/ErrorParser.js"],"sourcesContent":["import oktaUnderscore from '../../../util/underscore-wrapper.js';\nimport StringUtil from '../../../util/StringUtil.js';\n\nconst FIELD_REGEX = /^([\\S]+): (.+)$/;\nvar ErrorParser = {\n  /**\n   * Helper function that returns the json output of an xhr objext\n   * @param  {jqXhr} xhr\n   * @return {Object}\n   */\n  getResponseJSON: function (xhr) {\n    try {\n      return xhr.responseJSON || JSON.parse(xhr.responseText);\n    } catch (e) {// ignore error\n    }\n  },\n  /**\n   * Parses an error summary to extract a field name and an error message\n   * @param  {String} errorSummary The raw error summary\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorSummary: function (errorSummary) {\n    const matches = errorSummary.match(FIELD_REGEX); // error format is: `fieldName: The field cannot be left blank`\n\n    if (matches) {\n      return [matches[1], matches[2]];\n    }\n  },\n  /**\n   * Parses an error cause object to extract a field name from property attribute\n   * and an error message form errorSummary attribute. It looks to see if there is\n   * a custom override/translation for the erorrCause.reason before using the errorSummary\n   * @param  {Object} errorCause object\n   * @return {String[]} An array with two members: [field name, error message]\n   */\n  parseErrorCauseObject: function (errorCause) {\n    if (errorCause.property && errorCause.errorSummary) {\n      // avoid triggering sentry log for error event with no cause reason\n      const localizedMsg = errorCause.reason ? StringUtil.localize(errorCause.reason) : undefined;\n      const apiMsg = errorCause.errorSummary;\n      const field = errorCause.property;\n      const errorMessage = (localizedMsg === null || localizedMsg === void 0 ? void 0 : localizedMsg.indexOf('L10N_ERROR[')) === -1 ? localizedMsg : apiMsg;\n      return [field, errorMessage];\n    }\n  },\n  parseErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    return oktaUnderscore.map(responseJSON && responseJSON.errorCauses || [], function (errorCause) {\n      return ('' + errorCause.errorSummary).replace(FIELD_REGEX, '$2');\n    });\n  },\n  /**\n   * Parses the response for errors\n   * Returns a map of field names > array or error messages\n   * Example:\n   * ```javascript\n   * {\n   *   url: ['The field cannot be left blank', 'The field has to be a valid URI'],\n   *   name: ['The field cannot be left blank']\n   * }\n   * ```\n   * @param  {Object} resp\n   * @return {Object}\n   */\n  parseFieldErrors: function (resp) {\n    const responseJSON = this.getResponseJSON(resp);\n    const errors = {}; // xhr error object\n\n    if (responseJSON) {\n      /* eslint complexity: [2, 9] */\n      oktaUnderscore.each(responseJSON.errorCauses || [], function (cause) {\n        let res = [];\n        if (cause.property && cause.errorSummary) {\n          res = this.parseErrorCauseObject(cause);\n        } else if (cause.location && cause.errorSummary) {\n          // To handle new api error format for field level errors.\n          // Ignoring the reason attribute as the translation happens in the API layer and not in the client any more.\n          res = [cause.location, cause.errorSummary];\n        } else {\n          res = this.parseErrorSummary(cause && cause.errorSummary || '');\n        }\n        if (res) {\n          const fieldName = res[0];\n          const message = res[1];\n          errors[fieldName] || (errors[fieldName] = []);\n          errors[fieldName].push(message);\n        }\n      }, this);\n    } // validation key/value object\n    else if (oktaUnderscore.isObject(resp) && oktaUnderscore.size(resp)) {\n      oktaUnderscore.each(resp, function (msg, field) {\n        errors[field] = [msg];\n      });\n    }\n    return oktaUnderscore.size(errors) ? errors : undefined;\n  }\n};\n\nexport { ErrorParser as default };\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,qCAAqC;AAChE,OAAOC,UAAU,MAAM,6BAA6B;AAEpD,MAAMC,WAAW,GAAG,iBAAiB;AACrC,IAAIC,WAAW,GAAG;EAChB;AACF;AACA;AACA;AACA;EACEC,eAAe,EAAE,SAAAA,CAAUC,GAAG,EAAE;IAC9B,IAAI;MACF,OAAOA,GAAG,CAACC,YAAY,IAAIC,IAAI,CAACC,KAAK,CAACH,GAAG,CAACI,YAAY,CAAC;IACzD,CAAC,CAAC,OAAOC,CAAC,EAAE,CAAC;IAAA;EAEf,CAAC;EACD;AACF;AACA;AACA;AACA;EACEC,iBAAiB,EAAE,SAAAA,CAAUC,YAAY,EAAE;IACzC,MAAMC,OAAO,GAAGD,YAAY,CAACE,KAAK,CAACZ,WAAW,CAAC,CAAC,CAAC;;IAEjD,IAAIW,OAAO,EAAE;MACX,OAAO,CAACA,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;IACjC;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,qBAAqB,EAAE,SAAAA,CAAUC,UAAU,EAAE;IAC3C,IAAIA,UAAU,CAACC,QAAQ,IAAID,UAAU,CAACJ,YAAY,EAAE;MAClD;MACA,MAAMM,YAAY,GAAGF,UAAU,CAACG,MAAM,GAAGlB,UAAU,CAACmB,QAAQ,CAACJ,UAAU,CAACG,MAAM,CAAC,GAAGE,SAAS;MAC3F,MAAMC,MAAM,GAAGN,UAAU,CAACJ,YAAY;MACtC,MAAMW,KAAK,GAAGP,UAAU,CAACC,QAAQ;MACjC,MAAMO,YAAY,GAAG,CAACN,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,GAAGP,YAAY,GAAGI,MAAM;MACrJ,OAAO,CAACC,KAAK,EAAEC,YAAY,CAAC;IAC9B;EACF,CAAC;EACDE,WAAW,EAAE,SAAAA,CAAUC,IAAI,EAAE;IAC3B,MAAMrB,YAAY,GAAG,IAAI,CAACF,eAAe,CAACuB,IAAI,CAAC;IAC/C,OAAO3B,cAAc,CAAC4B,GAAG,CAACtB,YAAY,IAAIA,YAAY,CAACuB,WAAW,IAAI,EAAE,EAAE,UAAUb,UAAU,EAAE;MAC9F,OAAO,CAAC,EAAE,GAAGA,UAAU,CAACJ,YAAY,EAAEkB,OAAO,CAAC5B,WAAW,EAAE,IAAI,CAAC;IAClE,CAAC,CAAC;EACJ,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6B,gBAAgB,EAAE,SAAAA,CAAUJ,IAAI,EAAE;IAChC,MAAMrB,YAAY,GAAG,IAAI,CAACF,eAAe,CAACuB,IAAI,CAAC;IAC/C,MAAMK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEnB,IAAI1B,YAAY,EAAE;MAChB;MACAN,cAAc,CAACiC,IAAI,CAAC3B,YAAY,CAACuB,WAAW,IAAI,EAAE,EAAE,UAAUK,KAAK,EAAE;QACnE,IAAIC,GAAG,GAAG,EAAE;QACZ,IAAID,KAAK,CAACjB,QAAQ,IAAIiB,KAAK,CAACtB,YAAY,EAAE;UACxCuB,GAAG,GAAG,IAAI,CAACpB,qBAAqB,CAACmB,KAAK,CAAC;QACzC,CAAC,MAAM,IAAIA,KAAK,CAACE,QAAQ,IAAIF,KAAK,CAACtB,YAAY,EAAE;UAC/C;UACA;UACAuB,GAAG,GAAG,CAACD,KAAK,CAACE,QAAQ,EAAEF,KAAK,CAACtB,YAAY,CAAC;QAC5C,CAAC,MAAM;UACLuB,GAAG,GAAG,IAAI,CAACxB,iBAAiB,CAACuB,KAAK,IAAIA,KAAK,CAACtB,YAAY,IAAI,EAAE,CAAC;QACjE;QACA,IAAIuB,GAAG,EAAE;UACP,MAAME,SAAS,GAAGF,GAAG,CAAC,CAAC,CAAC;UACxB,MAAMG,OAAO,GAAGH,GAAG,CAAC,CAAC,CAAC;UACtBH,MAAM,CAACK,SAAS,CAAC,KAAKL,MAAM,CAACK,SAAS,CAAC,GAAG,EAAE,CAAC;UAC7CL,MAAM,CAACK,SAAS,CAAC,CAACE,IAAI,CAACD,OAAO,CAAC;QACjC;MACF,CAAC,EAAE,IAAI,CAAC;IACV,CAAC,CAAC;IAAA,KACG,IAAItC,cAAc,CAACwC,QAAQ,CAACb,IAAI,CAAC,IAAI3B,cAAc,CAACyC,IAAI,CAACd,IAAI,CAAC,EAAE;MACnE3B,cAAc,CAACiC,IAAI,CAACN,IAAI,EAAE,UAAUe,GAAG,EAAEnB,KAAK,EAAE;QAC9CS,MAAM,CAACT,KAAK,CAAC,GAAG,CAACmB,GAAG,CAAC;MACvB,CAAC,CAAC;IACJ;IACA,OAAO1C,cAAc,CAACyC,IAAI,CAACT,MAAM,CAAC,GAAGA,MAAM,GAAGX,SAAS;EACzD;AACF,CAAC;AAED,SAASlB,WAAW,IAAIwC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}