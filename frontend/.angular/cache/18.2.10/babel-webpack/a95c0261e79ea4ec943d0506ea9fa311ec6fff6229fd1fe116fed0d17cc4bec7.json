{"ast":null,"code":"import _asyncToGenerator from \"C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ConfiguredFlowError, ConfigError } from '../../util/Errors.js';\nimport { emailVerifyCallback } from './emailVerifyCallback.js';\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { CONFIGURED_FLOW } from './constants.js';\n\n/*!\n * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\nconst handleProxyIdxResponse = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (settings) {\n    return Promise.resolve({\n      rawIdxState: settings.get('proxyIdxResponse'),\n      context: settings.get('proxyIdxResponse'),\n      neededToProceed: []\n    });\n  });\n  return function handleProxyIdxResponse(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/* eslint max-depth: [2, 3] */\n// eslint-disable-next-line complexity, max-statements\nfunction startLoginFlow(_x2) {\n  return _startLoginFlow.apply(this, arguments);\n}\nfunction _startLoginFlow() {\n  _startLoginFlow = _asyncToGenerator(function* (settings) {\n    const authClient = settings.getAuthClient();\n    // nonce is not a top-level auth-js option, must be passed in manually\n    const {\n      authParams: authParams\n    } = settings.toJSON({\n      verbose: true\n    });\n    const nonce = settings.get('nonce') || (authParams === null || authParams === void 0 ? void 0 : authParams.nonce);\n    const idxOptions = {\n      exchangeCodeForTokens: false,\n      // we handle this in interactionCodeFlow.js\n      ...(nonce && {\n        nonce: nonce\n      })\n    };\n\n    // Return a preset response\n    if (settings.get('proxyIdxResponse')) {\n      return handleProxyIdxResponse(settings);\n    }\n    if (settings.get('overrideExistingStateToken')) {\n      sessionStorageHelper.removeStateHandle();\n    }\n    if (settings.get('otp')) {\n      return emailVerifyCallback(settings);\n    }\n    if (settings.get('oauth2Enabled')) {\n      const meta = yield authClient.idx.getSavedTransactionMeta();\n      if (!meta) {\n        // no saved transaction\n        // if the configured flow is set to `proceed`, the SIW should only continue an existing idx transaction\n        // if the SIW loads from a fresh state (there is no current transaction), throw an error\n        const flow = authClient.idx.getFlow();\n        if (flow && flow === CONFIGURED_FLOW.PROCEED) {\n          throw new ConfiguredFlowError('Unable to proceed: saved transaction could not be loaded', flow);\n        }\n        // start new transaction\n        return authClient.idx.start(idxOptions); // calls interact\n      }\n\n      // continue saved transaction\n      return authClient.idx.proceed(idxOptions); // calls introspect\n    }\n\n    // Use stateToken from session storage if exists\n    // See more details at ./docs/use-session-token-prior-to-settings.png\n    const stateHandleFromSession = sessionStorageHelper.getStateHandle();\n    if (stateHandleFromSession) {\n      try {\n        var _idxResp$context, _idxResp$context$mess;\n        const idxResp = yield authClient.idx.start({\n          ...idxOptions,\n          stateHandle: stateHandleFromSession\n        });\n        const hasError = ((_idxResp$context = idxResp.context) === null || _idxResp$context === void 0 ? void 0 : (_idxResp$context$mess = _idxResp$context.messages) === null || _idxResp$context$mess === void 0 ? void 0 : _idxResp$context$mess.value.length) > 0;\n        if (hasError) {\n          throw new Error('saved stateToken is invalid'); // will be caught in this function\n        }\n\n        // 1. abandon the settings.stateHandle given session.stateHandle is still valid\n        settings.set('stateToken', stateHandleFromSession);\n        // 2. chain the idxResp to next handler\n        return idxResp;\n      } catch {\n        // 1. remove session.stateHandle\n        sessionStorageHelper.removeStateHandle();\n        // 2. start the login again in order to introspect on settings.stateHandle\n        return startLoginFlow(settings);\n      }\n    }\n\n    // Use stateToken from options\n    const stateHandle = settings.get('stateToken');\n    if (stateHandle) {\n      return authClient.idx.start({\n        ...idxOptions,\n        stateHandle: stateHandle\n      });\n    }\n    throw new ConfigError('Invalid OIDC configuration. Set \"clientId\" and \"redirectUri\" in the widget options.');\n  });\n  return _startLoginFlow.apply(this, arguments);\n}\nexport { startLoginFlow };","map":{"version":3,"names":["ConfiguredFlowError","ConfigError","emailVerifyCallback","sessionStorageHelper","CONFIGURED_FLOW","handleProxyIdxResponse","_ref","_asyncToGenerator","settings","Promise","resolve","rawIdxState","get","context","neededToProceed","_x","apply","arguments","startLoginFlow","_x2","_startLoginFlow","authClient","getAuthClient","authParams","toJSON","verbose","nonce","idxOptions","exchangeCodeForTokens","removeStateHandle","meta","idx","getSavedTransactionMeta","flow","getFlow","PROCEED","start","proceed","stateHandleFromSession","getStateHandle","_idxResp$context","_idxResp$context$mess","idxResp","stateHandle","hasError","messages","value","length","Error","set"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/startLoginFlow.js"],"sourcesContent":["import { ConfiguredFlowError, ConfigError } from '../../util/Errors.js';\nimport { emailVerifyCallback } from './emailVerifyCallback.js';\nimport sessionStorageHelper from './sessionStorageHelper.js';\nimport { CONFIGURED_FLOW } from './constants.js';\n\n/*!\n * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\nconst handleProxyIdxResponse = async settings => {\n  return Promise.resolve({\n    rawIdxState: settings.get('proxyIdxResponse'),\n    context: settings.get('proxyIdxResponse'),\n    neededToProceed: []\n  });\n};\n\n/* eslint max-depth: [2, 3] */\n// eslint-disable-next-line complexity, max-statements\nasync function startLoginFlow(settings) {\n  const authClient = settings.getAuthClient();\n  // nonce is not a top-level auth-js option, must be passed in manually\n  const {\n    authParams: authParams\n  } = settings.toJSON({\n    verbose: true\n  });\n  const nonce = settings.get('nonce') || (authParams === null || authParams === void 0 ? void 0 : authParams.nonce);\n  const idxOptions = {\n    exchangeCodeForTokens: false,\n    // we handle this in interactionCodeFlow.js\n    ...(nonce && {\n      nonce: nonce\n    })\n  };\n\n  // Return a preset response\n  if (settings.get('proxyIdxResponse')) {\n    return handleProxyIdxResponse(settings);\n  }\n  if (settings.get('overrideExistingStateToken')) {\n    sessionStorageHelper.removeStateHandle();\n  }\n  if (settings.get('otp')) {\n    return emailVerifyCallback(settings);\n  }\n  if (settings.get('oauth2Enabled')) {\n    const meta = await authClient.idx.getSavedTransactionMeta();\n    if (!meta) {\n      // no saved transaction\n      // if the configured flow is set to `proceed`, the SIW should only continue an existing idx transaction\n      // if the SIW loads from a fresh state (there is no current transaction), throw an error\n      const flow = authClient.idx.getFlow();\n      if (flow && flow === CONFIGURED_FLOW.PROCEED) {\n        throw new ConfiguredFlowError('Unable to proceed: saved transaction could not be loaded', flow);\n      }\n      // start new transaction\n      return authClient.idx.start(idxOptions); // calls interact\n    }\n\n    // continue saved transaction\n    return authClient.idx.proceed(idxOptions); // calls introspect\n  }\n\n  // Use stateToken from session storage if exists\n  // See more details at ./docs/use-session-token-prior-to-settings.png\n  const stateHandleFromSession = sessionStorageHelper.getStateHandle();\n  if (stateHandleFromSession) {\n    try {\n      var _idxResp$context, _idxResp$context$mess;\n      const idxResp = await authClient.idx.start({\n        ...idxOptions,\n        stateHandle: stateHandleFromSession\n      });\n      const hasError = ((_idxResp$context = idxResp.context) === null || _idxResp$context === void 0 ? void 0 : (_idxResp$context$mess = _idxResp$context.messages) === null || _idxResp$context$mess === void 0 ? void 0 : _idxResp$context$mess.value.length) > 0;\n      if (hasError) {\n        throw new Error('saved stateToken is invalid'); // will be caught in this function\n      }\n\n      // 1. abandon the settings.stateHandle given session.stateHandle is still valid\n      settings.set('stateToken', stateHandleFromSession);\n      // 2. chain the idxResp to next handler\n      return idxResp;\n    } catch {\n      // 1. remove session.stateHandle\n      sessionStorageHelper.removeStateHandle();\n      // 2. start the login again in order to introspect on settings.stateHandle\n      return startLoginFlow(settings);\n    }\n  }\n\n  // Use stateToken from options\n  const stateHandle = settings.get('stateToken');\n  if (stateHandle) {\n    return authClient.idx.start({\n      ...idxOptions,\n      stateHandle: stateHandle\n    });\n  }\n  throw new ConfigError('Invalid OIDC configuration. Set \"clientId\" and \"redirectUri\" in the widget options.');\n}\n\nexport { startLoginFlow };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}