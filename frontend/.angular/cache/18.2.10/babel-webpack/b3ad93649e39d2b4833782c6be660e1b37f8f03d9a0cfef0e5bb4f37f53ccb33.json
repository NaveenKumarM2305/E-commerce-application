{"ast":null,"code":"import _asyncToGenerator from \"C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { clone } from '../util/object.js';\nimport { getOAuthUrls } from './util/oauth.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport OAuthError from '../errors/OAuthError.js';\nimport '../errors/WWWAuthError.js';\nimport { verifyToken } from './verifyToken.js';\nimport { getDefaultTokenParams } from './util/defaultTokenParams.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport './types/Token.js';\nfunction validateResponse(res, oauthParams) {\n  if (res['error'] && res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n  if (oauthParams.dpop && res.token_type !== 'DPoP') {\n    throw new AuthSdkError('Unable to parse OAuth flow response: DPoP was configured but \"token_type\" was not DPoP');\n  }\n}\nfunction handleOAuthResponse(_x, _x2, _x3, _x4) {\n  return _handleOAuthResponse.apply(this, arguments);\n}\nfunction _handleOAuthResponse() {\n  _handleOAuthResponse = _asyncToGenerator(function* (sdk, tokenParams, res, urls) {\n    const pkce = sdk.options.pkce !== false;\n    if (pkce && (res.code || res.interaction_code)) {\n      return sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {\n        authorizationCode: res.code,\n        interactionCode: res.interaction_code\n      }), urls);\n    }\n    tokenParams = tokenParams || getDefaultTokenParams(sdk);\n    urls = urls || getOAuthUrls(sdk, tokenParams);\n    let responseType = tokenParams.responseType || [];\n    if (!Array.isArray(responseType) && responseType !== 'none') {\n      responseType = [responseType];\n    }\n    let scopes;\n    if (res.scope) {\n      scopes = res.scope.split(' ');\n    } else {\n      scopes = clone(tokenParams.scopes);\n    }\n    const clientId = tokenParams.clientId || sdk.options.clientId;\n    validateResponse(res, tokenParams);\n    const tokenDict = {};\n    const expiresIn = res.expires_in;\n    const tokenType = res.token_type;\n    const accessToken = res.access_token;\n    const idToken = res.id_token;\n    const refreshToken = res.refresh_token;\n    const now = Math.floor(Date.now() / 1000);\n    if (accessToken) {\n      const accessJwt = sdk.token.decode(accessToken);\n      tokenDict.accessToken = {\n        accessToken: accessToken,\n        claims: accessJwt.payload,\n        expiresAt: Number(expiresIn) + now,\n        tokenType: tokenType,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        userinfoUrl: urls.userinfoUrl\n      };\n      if (tokenParams.dpopPairId) {\n        tokenDict.accessToken.dpopPairId = tokenParams.dpopPairId;\n      }\n      if (tokenParams.extraParams) {\n        tokenDict.accessToken.extraParams = tokenParams.extraParams;\n      }\n    }\n    if (refreshToken) {\n      tokenDict.refreshToken = {\n        refreshToken: refreshToken,\n        expiresAt: Number(expiresIn) + now,\n        scopes: scopes,\n        tokenUrl: urls.tokenUrl,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer\n      };\n      if (tokenParams.dpopPairId) {\n        tokenDict.refreshToken.dpopPairId = tokenParams.dpopPairId;\n      }\n      if (tokenParams.extraParams) {\n        tokenDict.refreshToken.extraParams = tokenParams.extraParams;\n      }\n    }\n    if (idToken) {\n      const idJwt = sdk.token.decode(idToken);\n      const idTokenObj = {\n        idToken: idToken,\n        claims: idJwt.payload,\n        expiresAt: idJwt.payload.exp - idJwt.payload.iat + now,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer,\n        clientId: clientId\n      };\n      if (tokenParams.extraParams) {\n        idTokenObj.extraParams = tokenParams.extraParams;\n      }\n      const validationParams = {\n        clientId: clientId,\n        issuer: urls.issuer,\n        nonce: tokenParams.nonce,\n        accessToken: accessToken,\n        acrValues: tokenParams.acrValues\n      };\n      if (tokenParams.ignoreSignature !== undefined) {\n        validationParams.ignoreSignature = tokenParams.ignoreSignature;\n      }\n      yield verifyToken(sdk, idTokenObj, validationParams);\n      tokenDict.idToken = idTokenObj;\n    }\n    if (responseType.indexOf('token') !== -1 && !tokenDict.accessToken) {\n      throw new AuthSdkError('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n    }\n    if (responseType.indexOf('id_token') !== -1 && !tokenDict.idToken) {\n      throw new AuthSdkError('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n    }\n    return {\n      tokens: tokenDict,\n      state: res.state,\n      code: res.code,\n      responseType\n    };\n  });\n  return _handleOAuthResponse.apply(this, arguments);\n}\nexport { handleOAuthResponse };","map":{"version":3,"names":["clone","getOAuthUrls","AuthSdkError","OAuthError","verifyToken","getDefaultTokenParams","validateResponse","res","oauthParams","state","dpop","token_type","handleOAuthResponse","_x","_x2","_x3","_x4","_handleOAuthResponse","apply","arguments","_asyncToGenerator","sdk","tokenParams","urls","pkce","options","code","interaction_code","token","exchangeCodeForTokens","Object","assign","authorizationCode","interactionCode","responseType","Array","isArray","scopes","scope","split","clientId","tokenDict","expiresIn","expires_in","tokenType","accessToken","access_token","idToken","id_token","refreshToken","refresh_token","now","Math","floor","Date","accessJwt","decode","claims","payload","expiresAt","Number","authorizeUrl","userinfoUrl","dpopPairId","extraParams","tokenUrl","issuer","idJwt","idTokenObj","exp","iat","validationParams","nonce","acrValues","ignoreSignature","undefined","indexOf","tokens"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-auth-js/esm/browser/oidc/handleOAuthResponse.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { clone } from '../util/object.js';\nimport { getOAuthUrls } from './util/oauth.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport OAuthError from '../errors/OAuthError.js';\nimport '../errors/WWWAuthError.js';\nimport { verifyToken } from './verifyToken.js';\nimport { getDefaultTokenParams } from './util/defaultTokenParams.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport './types/Token.js';\n\nfunction validateResponse(res, oauthParams) {\n    if (res['error'] && res['error_description']) {\n        throw new OAuthError(res['error'], res['error_description']);\n    }\n    if (res.state !== oauthParams.state) {\n        throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n    }\n    if (oauthParams.dpop && res.token_type !== 'DPoP') {\n        throw new AuthSdkError('Unable to parse OAuth flow response: DPoP was configured but \"token_type\" was not DPoP');\n    }\n}\nasync function handleOAuthResponse(sdk, tokenParams, res, urls) {\n    const pkce = sdk.options.pkce !== false;\n    if (pkce && (res.code || res.interaction_code)) {\n        return sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {\n            authorizationCode: res.code,\n            interactionCode: res.interaction_code\n        }), urls);\n    }\n    tokenParams = tokenParams || getDefaultTokenParams(sdk);\n    urls = urls || getOAuthUrls(sdk, tokenParams);\n    let responseType = tokenParams.responseType || [];\n    if (!Array.isArray(responseType) && responseType !== 'none') {\n        responseType = [responseType];\n    }\n    let scopes;\n    if (res.scope) {\n        scopes = res.scope.split(' ');\n    }\n    else {\n        scopes = clone(tokenParams.scopes);\n    }\n    const clientId = tokenParams.clientId || sdk.options.clientId;\n    validateResponse(res, tokenParams);\n    const tokenDict = {};\n    const expiresIn = res.expires_in;\n    const tokenType = res.token_type;\n    const accessToken = res.access_token;\n    const idToken = res.id_token;\n    const refreshToken = res.refresh_token;\n    const now = Math.floor(Date.now() / 1000);\n    if (accessToken) {\n        const accessJwt = sdk.token.decode(accessToken);\n        tokenDict.accessToken = {\n            accessToken: accessToken,\n            claims: accessJwt.payload,\n            expiresAt: Number(expiresIn) + now,\n            tokenType: tokenType,\n            scopes: scopes,\n            authorizeUrl: urls.authorizeUrl,\n            userinfoUrl: urls.userinfoUrl\n        };\n        if (tokenParams.dpopPairId) {\n            tokenDict.accessToken.dpopPairId = tokenParams.dpopPairId;\n        }\n        if (tokenParams.extraParams) {\n            tokenDict.accessToken.extraParams = tokenParams.extraParams;\n        }\n    }\n    if (refreshToken) {\n        tokenDict.refreshToken = {\n            refreshToken: refreshToken,\n            expiresAt: Number(expiresIn) + now,\n            scopes: scopes,\n            tokenUrl: urls.tokenUrl,\n            authorizeUrl: urls.authorizeUrl,\n            issuer: urls.issuer,\n        };\n        if (tokenParams.dpopPairId) {\n            tokenDict.refreshToken.dpopPairId = tokenParams.dpopPairId;\n        }\n        if (tokenParams.extraParams) {\n            tokenDict.refreshToken.extraParams = tokenParams.extraParams;\n        }\n    }\n    if (idToken) {\n        const idJwt = sdk.token.decode(idToken);\n        const idTokenObj = {\n            idToken: idToken,\n            claims: idJwt.payload,\n            expiresAt: idJwt.payload.exp - idJwt.payload.iat + now,\n            scopes: scopes,\n            authorizeUrl: urls.authorizeUrl,\n            issuer: urls.issuer,\n            clientId: clientId\n        };\n        if (tokenParams.extraParams) {\n            idTokenObj.extraParams = tokenParams.extraParams;\n        }\n        const validationParams = {\n            clientId: clientId,\n            issuer: urls.issuer,\n            nonce: tokenParams.nonce,\n            accessToken: accessToken,\n            acrValues: tokenParams.acrValues\n        };\n        if (tokenParams.ignoreSignature !== undefined) {\n            validationParams.ignoreSignature = tokenParams.ignoreSignature;\n        }\n        await verifyToken(sdk, idTokenObj, validationParams);\n        tokenDict.idToken = idTokenObj;\n    }\n    if (responseType.indexOf('token') !== -1 && !tokenDict.accessToken) {\n        throw new AuthSdkError('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n    }\n    if (responseType.indexOf('id_token') !== -1 && !tokenDict.idToken) {\n        throw new AuthSdkError('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n    }\n    return {\n        tokens: tokenDict,\n        state: res.state,\n        code: res.code,\n        responseType\n    };\n}\n\nexport { handleOAuthResponse };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}