{"ast":null,"code":"import _asyncToGenerator from \"C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../_virtual/_tslib.js';\nimport * as index from '../../crypto/index.js';\nimport { httpRequest } from '../../http/request.js';\nimport { PromiseQueue } from '../../util/PromiseQueue.js';\nimport { isFunction } from '../../util/types.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport 'cross-fetch';\nimport PKCE from '../util/pkce.js';\nimport { createTokenAPI, createEndpoints } from '../factory/api.js';\nimport { TokenManager } from '../TokenManager.js';\nimport WWWAuthError from '../../errors/WWWAuthError.js';\nimport { getOAuthUrls } from '../util/oauth.js';\nimport { isLoginRedirect, hasResponseType } from '../util/loginRedirect.js';\nimport '../types/Token.js';\nimport { clearDPoPKeyPairAfterRevoke, clearDPoPKeyPair, findKeyPair, generateDPoPProof, clearAllDPoPKeyPairs, isDPoPNonceError } from '../dpop.js';\nimport { provideOriginalUri } from './browser.js';\nfunction mixinOAuth(Base, TransactionManagerConstructor) {\n  var _a;\n  const WithOriginalUri = provideOriginalUri(Base);\n  return _a = class OktaAuthOAuth extends WithOriginalUri {\n    constructor(...args) {\n      super(...args);\n      this.transactionManager = new TransactionManagerConstructor(Object.assign({\n        storageManager: this.storageManager\n      }, this.options.transactionManager));\n      this.pkce = {\n        DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,\n        generateVerifier: PKCE.generateVerifier,\n        computeChallenge: PKCE.computeChallenge\n      };\n      this._pending = {\n        handleLogin: false\n      };\n      this._tokenQueue = new PromiseQueue();\n      this.token = createTokenAPI(this, this._tokenQueue);\n      this.tokenManager = new TokenManager(this, this.options.tokenManager);\n      this.endpoints = createEndpoints(this);\n    }\n    clearStorage() {\n      super.clearStorage();\n      this.tokenManager.clear();\n    }\n    isAuthenticated(options = {}) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const {\n          autoRenew,\n          autoRemove\n        } = _this.tokenManager.getOptions();\n        const shouldRenew = options.onExpiredToken ? options.onExpiredToken === 'renew' : autoRenew;\n        const shouldRemove = options.onExpiredToken ? options.onExpiredToken === 'remove' : autoRemove;\n        let {\n          accessToken\n        } = _this.tokenManager.getTokensSync();\n        if (accessToken && _this.tokenManager.hasExpired(accessToken)) {\n          accessToken = undefined;\n          if (shouldRenew) {\n            try {\n              accessToken = yield _this.tokenManager.renew('accessToken');\n            } catch (_a) {}\n          } else if (shouldRemove) {\n            _this.tokenManager.remove('accessToken');\n          }\n        }\n        let {\n          idToken\n        } = _this.tokenManager.getTokensSync();\n        if (idToken && _this.tokenManager.hasExpired(idToken)) {\n          idToken = undefined;\n          if (shouldRenew) {\n            try {\n              idToken = yield _this.tokenManager.renew('idToken');\n            } catch (_b) {}\n          } else if (shouldRemove) {\n            _this.tokenManager.remove('idToken');\n          }\n        }\n        return !!(accessToken && idToken);\n      })();\n    }\n    signInWithRedirect(opts = {}) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const {\n            originalUri\n          } = opts,\n          additionalParams = __rest(opts, [\"originalUri\"]);\n        if (_this2._pending.handleLogin) {\n          return;\n        }\n        _this2._pending.handleLogin = true;\n        try {\n          if (originalUri) {\n            _this2.setOriginalUri(originalUri);\n          }\n          const params = Object.assign({\n            scopes: _this2.options.scopes || ['openid', 'email', 'profile']\n          }, additionalParams);\n          yield _this2.token.getWithRedirect(params);\n        } finally {\n          _this2._pending.handleLogin = false;\n        }\n      })();\n    }\n    getUser() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const {\n          idToken,\n          accessToken\n        } = _this3.tokenManager.getTokensSync();\n        return _this3.token.getUserInfo(accessToken, idToken);\n      })();\n    }\n    getIdToken() {\n      const {\n        idToken\n      } = this.tokenManager.getTokensSync();\n      return idToken ? idToken.idToken : undefined;\n    }\n    getAccessToken() {\n      const {\n        accessToken\n      } = this.tokenManager.getTokensSync();\n      return accessToken ? accessToken.accessToken : undefined;\n    }\n    getRefreshToken() {\n      const {\n        refreshToken\n      } = this.tokenManager.getTokensSync();\n      return refreshToken ? refreshToken.refreshToken : undefined;\n    }\n    getOrRenewAccessToken() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        var _a;\n        const {\n          accessToken\n        } = _this4.tokenManager.getTokensSync();\n        if (accessToken && !_this4.tokenManager.hasExpired(accessToken)) {\n          return accessToken.accessToken;\n        }\n        try {\n          const key = _this4.tokenManager.getStorageKeyByType('accessToken');\n          const token = yield _this4.tokenManager.renew(key !== null && key !== void 0 ? key : 'accessToken');\n          return (_a = token === null || token === void 0 ? void 0 : token.accessToken) !== null && _a !== void 0 ? _a : null;\n        } catch (err) {\n          _this4.emitter.emit('error', err);\n          return null;\n        }\n      })();\n    }\n    storeTokensFromRedirect() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        const {\n          tokens,\n          responseType\n        } = yield _this5.token.parseFromUrl();\n        if (responseType !== 'none') {\n          _this5.tokenManager.setTokens(tokens);\n        }\n      })();\n    }\n    isLoginRedirect() {\n      return isLoginRedirect(this);\n    }\n    isPKCE() {\n      return !!this.options.pkce;\n    }\n    hasResponseType(responseType) {\n      return hasResponseType(responseType, this.options);\n    }\n    isAuthorizationCodeFlow() {\n      return this.hasResponseType('code');\n    }\n    invokeApiMethod(options) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        if (!options.accessToken) {\n          const accessToken = (yield _this6.tokenManager.getTokens()).accessToken;\n          options.accessToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.accessToken;\n        }\n        return httpRequest(_this6, options);\n      })();\n    }\n    revokeAccessToken(accessToken) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        if (!accessToken) {\n          const tokens = yield _this7.tokenManager.getTokens();\n          accessToken = tokens.accessToken;\n          const accessTokenKey = _this7.tokenManager.getStorageKeyByType('accessToken');\n          _this7.tokenManager.remove(accessTokenKey);\n          if (_this7.options.dpop) {\n            yield clearDPoPKeyPairAfterRevoke('access', tokens);\n          }\n        }\n        if (!accessToken) {\n          return Promise.resolve(null);\n        }\n        return _this7.token.revoke(accessToken);\n      })();\n    }\n    revokeRefreshToken(refreshToken) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        if (!refreshToken) {\n          const tokens = yield _this8.tokenManager.getTokens();\n          refreshToken = tokens.refreshToken;\n          const refreshTokenKey = _this8.tokenManager.getStorageKeyByType('refreshToken');\n          _this8.tokenManager.remove(refreshTokenKey);\n          if (_this8.options.dpop) {\n            yield clearDPoPKeyPairAfterRevoke('refresh', tokens);\n          }\n        }\n        if (!refreshToken) {\n          return Promise.resolve(null);\n        }\n        return _this8.token.revoke(refreshToken);\n      })();\n    }\n    getSignOutRedirectUrl(options = {}) {\n      let {\n        idToken,\n        postLogoutRedirectUri,\n        state\n      } = options;\n      if (!idToken) {\n        idToken = this.tokenManager.getTokensSync().idToken;\n      }\n      if (!idToken) {\n        return '';\n      }\n      if (postLogoutRedirectUri === undefined) {\n        postLogoutRedirectUri = this.options.postLogoutRedirectUri;\n      }\n      const logoutUrl = getOAuthUrls(this).logoutUrl;\n      const idTokenHint = idToken.idToken;\n      let logoutUri = logoutUrl + '?id_token_hint=' + encodeURIComponent(idTokenHint);\n      if (postLogoutRedirectUri) {\n        logoutUri += '&post_logout_redirect_uri=' + encodeURIComponent(postLogoutRedirectUri);\n      }\n      if (state) {\n        logoutUri += '&state=' + encodeURIComponent(state);\n      }\n      return logoutUri;\n    }\n    signOut(options) {\n      var _this9 = this;\n      return _asyncToGenerator(function* () {\n        var _a;\n        options = Object.assign({}, options);\n        const defaultUri = window.location.origin;\n        const currentUri = window.location.href;\n        const postLogoutRedirectUri = options.postLogoutRedirectUri === null ? null : options.postLogoutRedirectUri || _this9.options.postLogoutRedirectUri || defaultUri;\n        const state = options === null || options === void 0 ? void 0 : options.state;\n        let accessToken = options.accessToken;\n        let refreshToken = options.refreshToken;\n        const revokeAccessToken = options.revokeAccessToken !== false;\n        const revokeRefreshToken = options.revokeRefreshToken !== false;\n        if (revokeRefreshToken && typeof refreshToken === 'undefined') {\n          refreshToken = _this9.tokenManager.getTokensSync().refreshToken;\n        }\n        if (revokeAccessToken && typeof accessToken === 'undefined') {\n          accessToken = _this9.tokenManager.getTokensSync().accessToken;\n        }\n        if (!options.idToken) {\n          options.idToken = _this9.tokenManager.getTokensSync().idToken;\n        }\n        if (revokeRefreshToken && refreshToken) {\n          yield _this9.revokeRefreshToken(refreshToken);\n        }\n        if (revokeAccessToken && accessToken) {\n          yield _this9.revokeAccessToken(accessToken);\n        }\n        const dpopPairId = (_a = accessToken === null || accessToken === void 0 ? void 0 : accessToken.dpopPairId) !== null && _a !== void 0 ? _a : refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.dpopPairId;\n        if (_this9.options.dpop && dpopPairId) {\n          yield clearDPoPKeyPair(dpopPairId);\n        }\n        const logoutUri = _this9.getSignOutRedirectUrl(Object.assign(Object.assign({}, options), {\n          postLogoutRedirectUri\n        }));\n        if (!logoutUri) {\n          const sessionClosed = yield _this9.closeSession();\n          const redirectUri = new URL(postLogoutRedirectUri || defaultUri);\n          if (state) {\n            redirectUri.searchParams.append('state', state);\n          }\n          if (postLogoutRedirectUri === currentUri) {\n            window.location.href = redirectUri.href;\n          } else {\n            window.location.assign(redirectUri.href);\n          }\n          return sessionClosed;\n        } else {\n          if (options.clearTokensBeforeRedirect) {\n            _this9.tokenManager.clear();\n          } else {\n            _this9.tokenManager.addPendingRemoveFlags();\n          }\n          window.location.assign(logoutUri);\n          return true;\n        }\n      })();\n    }\n    getDPoPAuthorizationHeaders(params) {\n      var _this10 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this10.options.dpop) {\n          throw new AuthSdkError('DPoP is not configured for this client instance');\n        }\n        let {\n          accessToken\n        } = params;\n        if (!accessToken) {\n          accessToken = _this10.tokenManager.getTokensSync().accessToken;\n        }\n        if (!accessToken) {\n          throw new AuthSdkError('AccessToken is required to generate a DPoP Proof');\n        }\n        const keyPair = yield findKeyPair(accessToken === null || accessToken === void 0 ? void 0 : accessToken.dpopPairId);\n        const proof = yield generateDPoPProof(Object.assign(Object.assign({}, params), {\n          keyPair,\n          accessToken: accessToken.accessToken\n        }));\n        return {\n          Authorization: `DPoP ${accessToken.accessToken}`,\n          Dpop: proof\n        };\n      })();\n    }\n    clearDPoPStorage(clearAll = false) {\n      var _this11 = this;\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n        if (clearAll) {\n          return clearAllDPoPKeyPairs();\n        }\n        const tokens = yield _this11.tokenManager.getTokens();\n        const keyPair = ((_a = tokens.accessToken) === null || _a === void 0 ? void 0 : _a.dpopPairId) || ((_b = tokens.refreshToken) === null || _b === void 0 ? void 0 : _b.dpopPairId);\n        if (keyPair) {\n          yield clearDPoPKeyPair(keyPair);\n        }\n      })();\n    }\n    parseUseDPoPNonceError(headers) {\n      var _a;\n      const wwwAuth = WWWAuthError.getWWWAuthenticateHeader(headers);\n      const wwwErr = WWWAuthError.parseHeader(wwwAuth !== null && wwwAuth !== void 0 ? wwwAuth : '');\n      if (isDPoPNonceError(wwwErr)) {\n        let nonce = null;\n        if (isFunction(headers === null || headers === void 0 ? void 0 : headers.get)) {\n          nonce = headers.get('DPoP-Nonce');\n        }\n        nonce = (_a = nonce !== null && nonce !== void 0 ? nonce : headers['dpop-nonce']) !== null && _a !== void 0 ? _a : headers['DPoP-Nonce'];\n        return nonce;\n      }\n      return null;\n    }\n  }, _a.crypto = index, _a;\n}\nexport { mixinOAuth };","map":{"version":3,"names":["__rest","index","httpRequest","PromiseQueue","isFunction","AuthSdkError","PKCE","createTokenAPI","createEndpoints","TokenManager","WWWAuthError","getOAuthUrls","isLoginRedirect","hasResponseType","clearDPoPKeyPairAfterRevoke","clearDPoPKeyPair","findKeyPair","generateDPoPProof","clearAllDPoPKeyPairs","isDPoPNonceError","provideOriginalUri","mixinOAuth","Base","TransactionManagerConstructor","_a","WithOriginalUri","OktaAuthOAuth","constructor","args","transactionManager","Object","assign","storageManager","options","pkce","DEFAULT_CODE_CHALLENGE_METHOD","generateVerifier","computeChallenge","_pending","handleLogin","_tokenQueue","token","tokenManager","endpoints","clearStorage","clear","isAuthenticated","_this","_asyncToGenerator","autoRenew","autoRemove","getOptions","shouldRenew","onExpiredToken","shouldRemove","accessToken","getTokensSync","hasExpired","undefined","renew","remove","idToken","_b","signInWithRedirect","opts","_this2","originalUri","additionalParams","setOriginalUri","params","scopes","getWithRedirect","getUser","_this3","getUserInfo","getIdToken","getAccessToken","getRefreshToken","refreshToken","getOrRenewAccessToken","_this4","key","getStorageKeyByType","err","emitter","emit","storeTokensFromRedirect","_this5","tokens","responseType","parseFromUrl","setTokens","isPKCE","isAuthorizationCodeFlow","invokeApiMethod","_this6","getTokens","revokeAccessToken","_this7","accessTokenKey","dpop","Promise","resolve","revoke","revokeRefreshToken","_this8","refreshTokenKey","getSignOutRedirectUrl","postLogoutRedirectUri","state","logoutUrl","idTokenHint","logoutUri","encodeURIComponent","signOut","_this9","defaultUri","window","location","origin","currentUri","href","dpopPairId","sessionClosed","closeSession","redirectUri","URL","searchParams","append","clearTokensBeforeRedirect","addPendingRemoveFlags","getDPoPAuthorizationHeaders","_this10","keyPair","proof","Authorization","Dpop","clearDPoPStorage","clearAll","_this11","parseUseDPoPNonceError","headers","wwwAuth","getWWWAuthenticateHeader","wwwErr","parseHeader","nonce","get","crypto"],"sources":["C:/SpringBOot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@okta/okta-auth-js/esm/browser/oidc/mixin/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../_virtual/_tslib.js';\nimport * as index from '../../crypto/index.js';\nimport { httpRequest } from '../../http/request.js';\nimport { PromiseQueue } from '../../util/PromiseQueue.js';\nimport { isFunction } from '../../util/types.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport 'cross-fetch';\nimport PKCE from '../util/pkce.js';\nimport { createTokenAPI, createEndpoints } from '../factory/api.js';\nimport { TokenManager } from '../TokenManager.js';\nimport WWWAuthError from '../../errors/WWWAuthError.js';\nimport { getOAuthUrls } from '../util/oauth.js';\nimport { isLoginRedirect, hasResponseType } from '../util/loginRedirect.js';\nimport '../types/Token.js';\nimport { clearDPoPKeyPairAfterRevoke, clearDPoPKeyPair, findKeyPair, generateDPoPProof, clearAllDPoPKeyPairs, isDPoPNonceError } from '../dpop.js';\nimport { provideOriginalUri } from './browser.js';\n\nfunction mixinOAuth(Base, TransactionManagerConstructor) {\n    var _a;\n    const WithOriginalUri = provideOriginalUri(Base);\n    return _a = class OktaAuthOAuth extends WithOriginalUri {\n            constructor(...args) {\n                super(...args);\n                this.transactionManager = new TransactionManagerConstructor(Object.assign({\n                    storageManager: this.storageManager,\n                }, this.options.transactionManager));\n                this.pkce = {\n                    DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,\n                    generateVerifier: PKCE.generateVerifier,\n                    computeChallenge: PKCE.computeChallenge\n                };\n                this._pending = { handleLogin: false };\n                this._tokenQueue = new PromiseQueue();\n                this.token = createTokenAPI(this, this._tokenQueue);\n                this.tokenManager = new TokenManager(this, this.options.tokenManager);\n                this.endpoints = createEndpoints(this);\n            }\n            clearStorage() {\n                super.clearStorage();\n                this.tokenManager.clear();\n            }\n            async isAuthenticated(options = {}) {\n                const { autoRenew, autoRemove } = this.tokenManager.getOptions();\n                const shouldRenew = options.onExpiredToken ? options.onExpiredToken === 'renew' : autoRenew;\n                const shouldRemove = options.onExpiredToken ? options.onExpiredToken === 'remove' : autoRemove;\n                let { accessToken } = this.tokenManager.getTokensSync();\n                if (accessToken && this.tokenManager.hasExpired(accessToken)) {\n                    accessToken = undefined;\n                    if (shouldRenew) {\n                        try {\n                            accessToken = await this.tokenManager.renew('accessToken');\n                        }\n                        catch (_a) {\n                        }\n                    }\n                    else if (shouldRemove) {\n                        this.tokenManager.remove('accessToken');\n                    }\n                }\n                let { idToken } = this.tokenManager.getTokensSync();\n                if (idToken && this.tokenManager.hasExpired(idToken)) {\n                    idToken = undefined;\n                    if (shouldRenew) {\n                        try {\n                            idToken = await this.tokenManager.renew('idToken');\n                        }\n                        catch (_b) {\n                        }\n                    }\n                    else if (shouldRemove) {\n                        this.tokenManager.remove('idToken');\n                    }\n                }\n                return !!(accessToken && idToken);\n            }\n            async signInWithRedirect(opts = {}) {\n                const { originalUri } = opts, additionalParams = __rest(opts, [\"originalUri\"]);\n                if (this._pending.handleLogin) {\n                    return;\n                }\n                this._pending.handleLogin = true;\n                try {\n                    if (originalUri) {\n                        this.setOriginalUri(originalUri);\n                    }\n                    const params = Object.assign({\n                        scopes: this.options.scopes || ['openid', 'email', 'profile']\n                    }, additionalParams);\n                    await this.token.getWithRedirect(params);\n                }\n                finally {\n                    this._pending.handleLogin = false;\n                }\n            }\n            async getUser() {\n                const { idToken, accessToken } = this.tokenManager.getTokensSync();\n                return this.token.getUserInfo(accessToken, idToken);\n            }\n            getIdToken() {\n                const { idToken } = this.tokenManager.getTokensSync();\n                return idToken ? idToken.idToken : undefined;\n            }\n            getAccessToken() {\n                const { accessToken } = this.tokenManager.getTokensSync();\n                return accessToken ? accessToken.accessToken : undefined;\n            }\n            getRefreshToken() {\n                const { refreshToken } = this.tokenManager.getTokensSync();\n                return refreshToken ? refreshToken.refreshToken : undefined;\n            }\n            async getOrRenewAccessToken() {\n                var _a;\n                const { accessToken } = this.tokenManager.getTokensSync();\n                if (accessToken && !this.tokenManager.hasExpired(accessToken)) {\n                    return accessToken.accessToken;\n                }\n                try {\n                    const key = this.tokenManager.getStorageKeyByType('accessToken');\n                    const token = await this.tokenManager.renew(key !== null && key !== void 0 ? key : 'accessToken');\n                    return (_a = token === null || token === void 0 ? void 0 : token.accessToken) !== null && _a !== void 0 ? _a : null;\n                }\n                catch (err) {\n                    this.emitter.emit('error', err);\n                    return null;\n                }\n            }\n            async storeTokensFromRedirect() {\n                const { tokens, responseType } = await this.token.parseFromUrl();\n                if (responseType !== 'none') {\n                    this.tokenManager.setTokens(tokens);\n                }\n            }\n            isLoginRedirect() {\n                return isLoginRedirect(this);\n            }\n            isPKCE() {\n                return !!this.options.pkce;\n            }\n            hasResponseType(responseType) {\n                return hasResponseType(responseType, this.options);\n            }\n            isAuthorizationCodeFlow() {\n                return this.hasResponseType('code');\n            }\n            async invokeApiMethod(options) {\n                if (!options.accessToken) {\n                    const accessToken = (await this.tokenManager.getTokens()).accessToken;\n                    options.accessToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.accessToken;\n                }\n                return httpRequest(this, options);\n            }\n            async revokeAccessToken(accessToken) {\n                if (!accessToken) {\n                    const tokens = await this.tokenManager.getTokens();\n                    accessToken = tokens.accessToken;\n                    const accessTokenKey = this.tokenManager.getStorageKeyByType('accessToken');\n                    this.tokenManager.remove(accessTokenKey);\n                    if (this.options.dpop) {\n                        await clearDPoPKeyPairAfterRevoke('access', tokens);\n                    }\n                }\n                if (!accessToken) {\n                    return Promise.resolve(null);\n                }\n                return this.token.revoke(accessToken);\n            }\n            async revokeRefreshToken(refreshToken) {\n                if (!refreshToken) {\n                    const tokens = await this.tokenManager.getTokens();\n                    refreshToken = tokens.refreshToken;\n                    const refreshTokenKey = this.tokenManager.getStorageKeyByType('refreshToken');\n                    this.tokenManager.remove(refreshTokenKey);\n                    if (this.options.dpop) {\n                        await clearDPoPKeyPairAfterRevoke('refresh', tokens);\n                    }\n                }\n                if (!refreshToken) {\n                    return Promise.resolve(null);\n                }\n                return this.token.revoke(refreshToken);\n            }\n            getSignOutRedirectUrl(options = {}) {\n                let { idToken, postLogoutRedirectUri, state, } = options;\n                if (!idToken) {\n                    idToken = this.tokenManager.getTokensSync().idToken;\n                }\n                if (!idToken) {\n                    return '';\n                }\n                if (postLogoutRedirectUri === undefined) {\n                    postLogoutRedirectUri = this.options.postLogoutRedirectUri;\n                }\n                const logoutUrl = getOAuthUrls(this).logoutUrl;\n                const idTokenHint = idToken.idToken;\n                let logoutUri = logoutUrl + '?id_token_hint=' + encodeURIComponent(idTokenHint);\n                if (postLogoutRedirectUri) {\n                    logoutUri += '&post_logout_redirect_uri=' + encodeURIComponent(postLogoutRedirectUri);\n                }\n                if (state) {\n                    logoutUri += '&state=' + encodeURIComponent(state);\n                }\n                return logoutUri;\n            }\n            async signOut(options) {\n                var _a;\n                options = Object.assign({}, options);\n                const defaultUri = window.location.origin;\n                const currentUri = window.location.href;\n                const postLogoutRedirectUri = options.postLogoutRedirectUri === null ? null :\n                    (options.postLogoutRedirectUri\n                        || this.options.postLogoutRedirectUri\n                        || defaultUri);\n                const state = options === null || options === void 0 ? void 0 : options.state;\n                let accessToken = options.accessToken;\n                let refreshToken = options.refreshToken;\n                const revokeAccessToken = options.revokeAccessToken !== false;\n                const revokeRefreshToken = options.revokeRefreshToken !== false;\n                if (revokeRefreshToken && typeof refreshToken === 'undefined') {\n                    refreshToken = this.tokenManager.getTokensSync().refreshToken;\n                }\n                if (revokeAccessToken && typeof accessToken === 'undefined') {\n                    accessToken = this.tokenManager.getTokensSync().accessToken;\n                }\n                if (!options.idToken) {\n                    options.idToken = this.tokenManager.getTokensSync().idToken;\n                }\n                if (revokeRefreshToken && refreshToken) {\n                    await this.revokeRefreshToken(refreshToken);\n                }\n                if (revokeAccessToken && accessToken) {\n                    await this.revokeAccessToken(accessToken);\n                }\n                const dpopPairId = (_a = accessToken === null || accessToken === void 0 ? void 0 : accessToken.dpopPairId) !== null && _a !== void 0 ? _a : refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.dpopPairId;\n                if (this.options.dpop && dpopPairId) {\n                    await clearDPoPKeyPair(dpopPairId);\n                }\n                const logoutUri = this.getSignOutRedirectUrl(Object.assign(Object.assign({}, options), { postLogoutRedirectUri }));\n                if (!logoutUri) {\n                    const sessionClosed = await this.closeSession();\n                    const redirectUri = new URL(postLogoutRedirectUri || defaultUri);\n                    if (state) {\n                        redirectUri.searchParams.append('state', state);\n                    }\n                    if (postLogoutRedirectUri === currentUri) {\n                        window.location.href = redirectUri.href;\n                    }\n                    else {\n                        window.location.assign(redirectUri.href);\n                    }\n                    return sessionClosed;\n                }\n                else {\n                    if (options.clearTokensBeforeRedirect) {\n                        this.tokenManager.clear();\n                    }\n                    else {\n                        this.tokenManager.addPendingRemoveFlags();\n                    }\n                    window.location.assign(logoutUri);\n                    return true;\n                }\n            }\n            async getDPoPAuthorizationHeaders(params) {\n                if (!this.options.dpop) {\n                    throw new AuthSdkError('DPoP is not configured for this client instance');\n                }\n                let { accessToken } = params;\n                if (!accessToken) {\n                    accessToken = (this.tokenManager.getTokensSync()).accessToken;\n                }\n                if (!accessToken) {\n                    throw new AuthSdkError('AccessToken is required to generate a DPoP Proof');\n                }\n                const keyPair = await findKeyPair(accessToken === null || accessToken === void 0 ? void 0 : accessToken.dpopPairId);\n                const proof = await generateDPoPProof(Object.assign(Object.assign({}, params), { keyPair, accessToken: accessToken.accessToken }));\n                return {\n                    Authorization: `DPoP ${accessToken.accessToken}`,\n                    Dpop: proof\n                };\n            }\n            async clearDPoPStorage(clearAll = false) {\n                var _a, _b;\n                if (clearAll) {\n                    return clearAllDPoPKeyPairs();\n                }\n                const tokens = await this.tokenManager.getTokens();\n                const keyPair = ((_a = tokens.accessToken) === null || _a === void 0 ? void 0 : _a.dpopPairId) || ((_b = tokens.refreshToken) === null || _b === void 0 ? void 0 : _b.dpopPairId);\n                if (keyPair) {\n                    await clearDPoPKeyPair(keyPair);\n                }\n            }\n            parseUseDPoPNonceError(headers) {\n                var _a;\n                const wwwAuth = WWWAuthError.getWWWAuthenticateHeader(headers);\n                const wwwErr = WWWAuthError.parseHeader(wwwAuth !== null && wwwAuth !== void 0 ? wwwAuth : '');\n                if (isDPoPNonceError(wwwErr)) {\n                    let nonce = null;\n                    if (isFunction(headers === null || headers === void 0 ? void 0 : headers.get)) {\n                        nonce = headers.get('DPoP-Nonce');\n                    }\n                    nonce = (_a = nonce !== null && nonce !== void 0 ? nonce : headers['dpop-nonce']) !== null && _a !== void 0 ? _a : headers['DPoP-Nonce'];\n                    return nonce;\n                }\n                return null;\n            }\n        },\n        _a.crypto = index,\n        _a;\n}\n\nexport { mixinOAuth };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}